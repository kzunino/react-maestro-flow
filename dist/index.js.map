{"version":3,"sources":["../src/wizard/graph.ts","../src/wizard/hooks.ts","../src/wizard/WizardContext.tsx","../src/wizard/Presenter.tsx","../src/wizard/path-params.ts","../src/wizard/state.ts","../src/wizard/url-params.ts","../src/wizard/Wizard.tsx"],"sourcesContent":["import type { WizardGraph, WizardNode, WizardState } from \"@/wizard/types\";\n\n/**\n * Creates a new empty wizard graph\n */\nexport function createWizardGraph(): WizardGraph {\n\treturn {\n\t\tnodes: new Map<string, WizardNode>(),\n\t};\n}\n\n/**\n * Registers a node in the wizard graph\n */\nexport function registerNode(graph: WizardGraph, node: WizardNode): void {\n\tif (graph.nodes.has(node.currentPage)) {\n\t\tthrow new Error(\n\t\t\t`Node with currentPage \"${node.currentPage}\" already exists in graph`,\n\t\t);\n\t}\n\n\tgraph.nodes.set(node.currentPage, node);\n\n\t// Set as entry point if it's the first node\n\tif (!graph.entryPoint) {\n\t\tgraph.entryPoint = node.currentPage;\n\t}\n}\n\n/**\n * Creates a wizard graph from an array of nodes\n * This is a convenience function for defining complete wizards in one place\n */\nexport function createWizardGraphFromNodes(\n\tnodes: WizardNode[],\n\tentryPoint?: string,\n): WizardGraph {\n\tconst graph = createWizardGraph();\n\n\tfor (const node of nodes) {\n\t\tregisterNode(graph, node);\n\t}\n\n\t// Override entry point if explicitly provided\n\tif (entryPoint) {\n\t\tif (!graph.nodes.has(entryPoint)) {\n\t\t\tthrow new Error(`Entry point \"${entryPoint}\" does not exist in nodes`);\n\t\t}\n\t\tgraph.entryPoint = entryPoint;\n\t}\n\n\treturn graph;\n}\n\n/**\n * Gets a node by its page identifier\n */\nexport function getNode(\n\tgraph: WizardGraph,\n\tpage: string,\n): WizardNode | undefined {\n\treturn graph.nodes.get(page);\n}\n\n/**\n * Checks if a step should be skipped based on its shouldSkip function and current state\n */\nexport function shouldSkipStep(\n\tgraph: WizardGraph,\n\tpage: string,\n\tstate: WizardState,\n): boolean {\n\tconst node = getNode(graph, page);\n\tif (!node) {\n\t\treturn false;\n\t}\n\n\tif (node.shouldSkip) {\n\t\treturn node.shouldSkip(state);\n\t}\n\n\treturn false;\n}\n\n/**\n * Resolves the next page(s) for a given node based on current state\n */\nexport function resolveNextPage(\n\tnode: WizardNode,\n\tstate: WizardState,\n): string | string[] | null {\n\tif (!node.nextPage) {\n\t\treturn null;\n\t}\n\n\t// If it's a function, evaluate it with current state\n\tif (typeof node.nextPage === \"function\") {\n\t\treturn node.nextPage(state);\n\t}\n\n\t// Otherwise, return the string or array directly\n\treturn node.nextPage;\n}\n\n/**\n * Recursively finds the next non-skipped page, preventing infinite loops\n */\nexport function getNextNonSkippedPage(\n\tgraph: WizardGraph,\n\tpage: string,\n\tstate: WizardState,\n\tvisited: Set<string> = new Set(),\n): string | null {\n\t// Prevent infinite loops\n\tif (visited.has(page)) {\n\t\tconsole.warn(`Circular skip condition detected for page \"${page}\"`);\n\t\treturn null;\n\t}\n\tvisited.add(page);\n\n\t// Check if current page should be skipped\n\tif (shouldSkipStep(graph, page, state)) {\n\t\tconst node = getNode(graph, page);\n\t\tif (!node) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst next = resolveNextPage(node, state);\n\t\tif (next === null) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// If it's an array, try the first page\n\t\tconst nextPage = Array.isArray(next) ? next[0] : next;\n\n\t\tif (!nextPage || !graph.nodes.has(nextPage)) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// Recursively check the next page\n\t\treturn getNextNonSkippedPage(graph, nextPage, state, visited);\n\t}\n\n\t// Page should not be skipped, return it\n\treturn page;\n}\n\n/**\n * Gets the next page for navigation (returns first page if multiple)\n * Automatically skips steps that should be skipped\n */\nexport function getNextPage(\n\tgraph: WizardGraph,\n\tcurrentPage: string,\n\tstate: WizardState,\n): string | null {\n\tconst currentNode = getNode(graph, currentPage);\n\tif (!currentNode) {\n\t\treturn null;\n\t}\n\n\tconst next = resolveNextPage(currentNode, state);\n\n\tif (next === null) {\n\t\treturn null;\n\t}\n\n\t// If it's an array, return the first page\n\tconst nextPage = Array.isArray(next)\n\t\t? next.length > 0\n\t\t\t? next[0]\n\t\t\t: null\n\t\t: next;\n\n\tif (!nextPage) {\n\t\treturn null;\n\t}\n\n\t// Validate that the next page exists in the graph\n\tif (!graph.nodes.has(nextPage)) {\n\t\tconsole.warn(`Next page \"${nextPage}\" does not exist in graph`);\n\t\treturn null;\n\t}\n\n\t// Check if the next page should be skipped and find the first non-skipped page\n\treturn getNextNonSkippedPage(graph, nextPage, state);\n}\n\n/**\n * Gets all possible next pages (useful for conditional branching)\n */\nexport function getAllNextPages(\n\tgraph: WizardGraph,\n\tcurrentPage: string,\n\tstate: WizardState,\n): string[] {\n\tconst currentNode = getNode(graph, currentPage);\n\tif (!currentNode) {\n\t\treturn [];\n\t}\n\n\tconst next = resolveNextPage(currentNode, state);\n\n\tif (next === null) {\n\t\treturn [];\n\t}\n\n\tif (Array.isArray(next)) {\n\t\t// Filter to only include pages that exist in the graph\n\t\treturn next.filter((page) => graph.nodes.has(page));\n\t}\n\n\t// Single page\n\tif (graph.nodes.has(next)) {\n\t\treturn [next];\n\t}\n\n\treturn [];\n}\n\n/**\n * Recursively finds the previous non-skipped page, preventing infinite loops\n */\nexport function getPreviousNonSkippedPage(\n\tgraph: WizardGraph,\n\tpage: string,\n\tstate: WizardState,\n\tvisited: Set<string> = new Set(),\n): string | null {\n\t// Prevent infinite loops\n\tif (visited.has(page)) {\n\t\tconsole.warn(`Circular skip condition detected for page \"${page}\"`);\n\t\treturn null;\n\t}\n\tvisited.add(page);\n\n\tconst node = getNode(graph, page);\n\tif (!node) {\n\t\treturn null;\n\t}\n\n\tif (!node.previousPageFallback) {\n\t\treturn null;\n\t}\n\n\t// Validate that the previous page exists\n\tif (!graph.nodes.has(node.previousPageFallback)) {\n\t\tconsole.warn(\n\t\t\t`Previous page \"${node.previousPageFallback}\" does not exist in graph`,\n\t\t);\n\t\treturn null;\n\t}\n\n\t// Check if previous page should be skipped\n\tif (shouldSkipStep(graph, node.previousPageFallback, state)) {\n\t\t// Recursively check the previous page\n\t\treturn getPreviousNonSkippedPage(\n\t\t\tgraph,\n\t\t\tnode.previousPageFallback,\n\t\t\tstate,\n\t\t\tvisited,\n\t\t);\n\t}\n\n\t// Previous page should not be skipped, return it\n\treturn node.previousPageFallback;\n}\n\n/**\n * Gets the previous page for a given node\n * Automatically skips over steps that should be skipped\n */\nexport function getPreviousPage(\n\tgraph: WizardGraph,\n\tcurrentPage: string,\n\tstate: WizardState,\n): string | null {\n\tconst currentNode = getNode(graph, currentPage);\n\tif (!currentNode) {\n\t\treturn null;\n\t}\n\n\tif (!currentNode.previousPageFallback) {\n\t\treturn null;\n\t}\n\n\t// Validate that the previous page exists\n\tif (!graph.nodes.has(currentNode.previousPageFallback)) {\n\t\tconsole.warn(\n\t\t\t`Previous page \"${currentNode.previousPageFallback}\" does not exist in graph`,\n\t\t);\n\t\treturn null;\n\t}\n\n\t// Check if previous page should be skipped and find the first non-skipped page\n\treturn getPreviousNonSkippedPage(graph, currentPage, state);\n}\n\n/**\n * Validates that all referenced pages in the graph exist\n */\nexport function validateGraph(graph: WizardGraph): {\n\tvalid: boolean;\n\terrors: string[];\n} {\n\tconst errors: string[] = [];\n\n\t// Check that entry point exists\n\tif (graph.entryPoint && !graph.nodes.has(graph.entryPoint)) {\n\t\terrors.push(`Entry point \"${graph.entryPoint}\" does not exist in graph`);\n\t}\n\n\t// Validate all node references\n\tfor (const [page, node] of graph.nodes.entries()) {\n\t\t// Check previousPageFallback reference\n\t\tif (\n\t\t\tnode.previousPageFallback &&\n\t\t\t!graph.nodes.has(node.previousPageFallback)\n\t\t) {\n\t\t\terrors.push(\n\t\t\t\t`Node \"${page}\" references non-existent previous page \"${node.previousPageFallback}\"`,\n\t\t\t);\n\t\t}\n\n\t\t// Check nextPage references (for string/array cases)\n\t\tif (node.nextPage && typeof node.nextPage !== \"function\") {\n\t\t\tconst nextPages = Array.isArray(node.nextPage)\n\t\t\t\t? node.nextPage\n\t\t\t\t: [node.nextPage];\n\t\t\tfor (const nextPage of nextPages) {\n\t\t\t\tif (!graph.nodes.has(nextPage)) {\n\t\t\t\t\terrors.push(\n\t\t\t\t\t\t`Node \"${page}\" references non-existent next page \"${nextPage}\"`,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn {\n\t\tvalid: errors.length === 0,\n\t\terrors,\n\t};\n}\n\n/**\n * Gets all pages in the graph in topological order (if possible)\n * Falls back to registration order if cycles exist\n */\nexport function getPagesInOrder(graph: WizardGraph): string[] {\n\tconst visited = new Set<string>();\n\tconst result: string[] = [];\n\n\tfunction visit(page: string) {\n\t\tif (visited.has(page)) {\n\t\t\treturn;\n\t\t}\n\n\t\tvisited.add(page);\n\t\tconst node = graph.nodes.get(page);\n\t\tif (!node) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Visit previous first (if exists)\n\t\tif (node.previousPageFallback) {\n\t\t\tvisit(node.previousPageFallback);\n\t\t}\n\n\t\tresult.push(page);\n\n\t\t// Visit next pages\n\t\tif (node.nextPage && typeof node.nextPage !== \"function\") {\n\t\t\tconst nextPages = Array.isArray(node.nextPage)\n\t\t\t\t? node.nextPage\n\t\t\t\t: [node.nextPage];\n\t\t\tfor (const nextPage of nextPages) {\n\t\t\t\tvisit(nextPage);\n\t\t\t}\n\t\t}\n\t}\n\n\t// Start from entry point or all nodes\n\tif (graph.entryPoint) {\n\t\tvisit(graph.entryPoint);\n\t}\n\n\t// Visit any remaining unvisited nodes\n\tfor (const page of graph.nodes.keys()) {\n\t\tif (!visited.has(page)) {\n\t\t\tvisit(page);\n\t\t}\n\t}\n\n\treturn result;\n}\n","\"use client\";\n\nimport { useCallback } from \"react\";\nimport type { UseWizardReturn } from \"@/wizard/types\";\nimport { useWizardContext } from \"@/wizard/WizardContext\";\n\n/**\n * Single hook to access all wizard functionality.\n * Use one import and destructure what you need.\n *\n * @example\n * const { goToNext, goToPrevious, goToPage, skipToPage, stateKey, currentPage, hasNext, hasPrevious } = useWizard();\n * const [name, setName] = stateKey(\"name\");\n * // goToPage(page) — jump to any node, preserve history (push). skipToPage(page) — same, replace (no back).\n */\nexport function useWizard(): UseWizardReturn {\n\tconst ctx = useWizardContext();\n\n\tconst stateKey = useCallback(\n\t\t<T = unknown>(key: string) => {\n\t\t\tconst value = (ctx.state[key] as T | undefined) ?? undefined;\n\t\t\tconst setValue = (newValue: T) => ctx.updateState(key, newValue);\n\t\t\treturn [value, setValue] as const;\n\t\t},\n\t\t[ctx.state, ctx.updateState],\n\t);\n\n\treturn {\n\t\t...ctx,\n\t\tstateKey,\n\t\thasNext: ctx.hasNext(),\n\t\thasPrevious: ctx.hasPrevious(),\n\t};\n}\n","\"use client\";\n\nimport { createContext, useContext } from \"react\";\nimport type { WizardContextValue } from \"@/wizard/types\";\n\n/**\n * React context for wizard state and navigation\n */\nexport const WizardContext = createContext<WizardContextValue | null>(null);\n\n/**\n * Hook to access wizard context\n * Throws an error if used outside of Wizard component\n */\nexport function useWizardContext(): WizardContextValue {\n\tconst context = useContext(WizardContext);\n\tif (!context) {\n\t\tthrow new Error(\"useWizardContext must be used within a Wizard component\");\n\t}\n\treturn context;\n}\n","import { lazy, Suspense, useMemo } from \"react\";\nimport type { ComponentLoader, WizardNode } from \"@/wizard/types\";\n\n/**\n * Props for the Presenter component\n */\nexport type PresenterProps = {\n\t/**\n\t * Current page identifier\n\t */\n\tpage: string | null;\n\n\t/**\n\t * Current node definition\n\t */\n\tnode: WizardNode | undefined;\n\n\t/**\n\t * Map of page identifiers to component loaders\n\t * Each loader should return a promise that resolves to a component with a default export\n\t */\n\tcomponentLoaders: Map<string, ComponentLoader>;\n\n\t/**\n\t * Optional fallback component to show while loading\n\t */\n\tloadingFallback?: React.ReactNode;\n\n\t/**\n\t * Optional fallback component to show for unknown pages\n\t */\n\tunknownPageFallback?: React.ReactNode;\n};\n\n/**\n * Default loading fallback\n */\nconst DefaultLoadingFallback = () => (\n\t<div className=\"flex items-center justify-center p-8\">\n\t\t<div className=\"text-muted-foreground\">Loading...</div>\n\t</div>\n);\n\n/**\n * Presenter component that dynamically loads and renders wizard pages\n * Uses React.lazy for code splitting and tree shaking\n * Dynamically loads components based on the provided componentLoaders map\n */\nexport function Presenter({\n\tpage,\n\tnode,\n\tcomponentLoaders,\n\tloadingFallback = <DefaultLoadingFallback />,\n\tunknownPageFallback,\n}: PresenterProps) {\n\t// Memoize the lazy-loaded component to prevent remounting on every render\n\tconst Component = useMemo(() => {\n\t\tif (!page) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst loader = componentLoaders.get(page);\n\t\tif (!loader) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// Use React.lazy to wrap the loader function\n\t\treturn lazy(loader);\n\t}, [page, componentLoaders]);\n\n\t// Handle special states (expired, not found) - don't require a node for these cases\n\tif (page === \"__expired__\" || page === \"__notfound__\") {\n\t\tif (!Component) {\n\t\t\treturn null;\n\t\t}\n\t\treturn (\n\t\t\t<Suspense fallback={loadingFallback}>\n\t\t\t\t<Component />\n\t\t\t</Suspense>\n\t\t);\n\t}\n\n\tif (!page || !node) {\n\t\treturn null;\n\t}\n\n\tif (!Component) {\n\t\tif (unknownPageFallback) {\n\t\t\treturn <>{unknownPageFallback}</>;\n\t\t}\n\t\treturn (\n\t\t\t<div className=\"flex items-center justify-center p-8\">\n\t\t\t\t<div className=\"text-destructive\">Unknown page: {page}</div>\n\t\t\t</div>\n\t\t);\n\t}\n\n\treturn (\n\t\t<Suspense fallback={loadingFallback}>\n\t\t\t<Component />\n\t\t</Suspense>\n\t);\n}\n","import type { UrlParamsAdapter } from \"@/wizard/types\";\n\n/**\n * Configuration for path-based URL parameters\n * Defines the structure of the URL path with named segments\n *\n * Example: \"/[id]/page/[page]\" would match \"/abc123/page/pageA\"\n * and extract { id: \"abc123\", page: \"pageA\" }\n */\nexport type PathConfig = {\n\t/**\n\t * Path template with named segments in brackets\n\t * Example: \"/[id]/page/[page]\" or \"/wizard/[id]/[page]\"\n\t */\n\ttemplate: string;\n\n\t/**\n\t * Base path to prepend to the template (optional)\n\t * Example: \"/wizard\" would make the full path \"/wizard/[id]/page/[page]\"\n\t */\n\tbasePath?: string;\n};\n\n/**\n * Parses a path template and extracts parameter names\n * Example: \"/[id]/page/[page]\" -> [\"id\", \"page\"]\n */\nfunction parsePathTemplate(template: string): string[] {\n\tconst matches = template.match(/\\[([^\\]]+)\\]/g);\n\tif (!matches) {\n\t\treturn [];\n\t}\n\treturn matches.map((match) => match.slice(1, -1));\n}\n\n/**\n * Builds a path from a template and parameter values\n * Example: template=\"/[id]/page/[page]\", params={id: \"abc\", page: \"pageA\"}\n * Result: \"/abc/page/pageA\"\n */\nfunction buildPath(template: string, params: Record<string, string>): string {\n\tlet path = template;\n\tfor (const [key, value] of Object.entries(params)) {\n\t\tpath = path.replace(`[${key}]`, encodeURIComponent(value));\n\t}\n\treturn path;\n}\n\n/**\n * Parses a URL path and extracts parameter values based on a template\n * Example: path=\"/en/wizard/abc/pageA\", template=\"/wizard/[id]/[page]\"\n * Result: { id: \"abc\", page: \"pageA\" }\n */\nfunction parsePath(path: string, template: string): Record<string, string> {\n\tconst params: Record<string, string> = {};\n\tconst paramNames = parsePathTemplate(template);\n\n\tif (paramNames.length === 0) {\n\t\treturn params;\n\t}\n\n\t// Convert template to regex pattern\n\t// Allow optional leading segments (like /en) before the template\n\tconst pattern = template\n\t\t.replace(/\\[([^\\]]+)\\]/g, \"([^/]+)\") // Replace [param] with capture group\n\t\t.replace(/\\//g, \"\\\\/\"); // Escape slashes\n\n\t// Make the pattern match from the end or allow optional prefix\n\t// This handles cases like /en/wizard/[id]/[page] matching /en/wizard/abc/pageA\n\tconst regex = new RegExp(`${pattern}$`);\n\tconst matches = path.match(regex);\n\n\tif (matches) {\n\t\t// matches[0] is the full match, matches[1..] are the captured groups\n\t\tfor (let i = 0; i < paramNames.length; i++) {\n\t\t\tconst value = matches[i + 1];\n\t\t\tif (value) {\n\t\t\t\tparams[paramNames[i]] = decodeURIComponent(value);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn params;\n}\n\n/**\n * Creates a path-based URL params adapter\n * This adapter uses URL path segments instead of query parameters\n *\n * @param config - Path configuration defining the URL structure\n * @returns A UrlParamsAdapter that works with path segments\n *\n * @example\n * ```ts\n * const adapter = createPathParamsAdapter({\n *   template: \"/[id]/page/[page]\"\n * });\n * // URLs will be like: /abc123/page/pageA\n * ```\n */\nexport function createPathParamsAdapter(config: PathConfig): UrlParamsAdapter {\n\tconst fullTemplate = config.basePath\n\t\t? `${config.basePath}${config.template}`\n\t\t: config.template;\n\n\tconst paramNames = parsePathTemplate(fullTemplate);\n\n\tconst getCurrentPath = (): string => {\n\t\tif (typeof window === \"undefined\") {\n\t\t\treturn \"\";\n\t\t}\n\t\treturn window.location.pathname;\n\t};\n\n\tconst getCurrentParams = (): Record<string, string> => {\n\t\tconst path = getCurrentPath();\n\t\treturn parsePath(path, fullTemplate);\n\t};\n\n\tconst buildFullPath = (params: Record<string, string>): string => {\n\t\t// Get current params and merge with new ones\n\t\tconst currentParams = getCurrentParams();\n\t\tconst mergedParams = { ...currentParams, ...params };\n\n\t\t// Ensure all required params are present\n\t\tfor (const paramName of paramNames) {\n\t\t\tif (!mergedParams[paramName]) {\n\t\t\t\t// Keep existing value if available\n\t\t\t\tconst currentValue = getCurrentParams()[paramName];\n\t\t\t\tif (currentValue) {\n\t\t\t\t\tmergedParams[paramName] = currentValue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst newPath = buildPath(fullTemplate, mergedParams);\n\n\t\t// If the current path has segments before our template (like /en),\n\t\t// preserve them in the new path\n\t\tconst currentPath = getCurrentPath();\n\t\tconst templateStart = currentPath.indexOf(fullTemplate.split(\"[\")[0]);\n\t\tif (templateStart > 0) {\n\t\t\t// There's a prefix before our template, preserve it\n\t\t\tconst prefix = currentPath.slice(0, templateStart);\n\t\t\treturn prefix + newPath;\n\t\t}\n\n\t\treturn newPath;\n\t};\n\n\treturn {\n\t\tgetParam: (key: string): string | null => {\n\t\t\tconst params = getCurrentParams();\n\t\t\treturn params[key] || null;\n\t\t},\n\n\t\tsetParam: (key: string, value: string): void => {\n\t\t\tif (typeof window === \"undefined\") {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Only update if this param is in the template\n\t\t\tif (!paramNames.includes(key)) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t`Parameter \"${key}\" is not defined in path template: ${fullTemplate}`,\n\t\t\t\t);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst newPath = buildFullPath({ [key]: value });\n\t\t\twindow.history.pushState({}, \"\", newPath);\n\t\t},\n\n\t\treplaceParam: (key: string, value: string): void => {\n\t\t\tif (typeof window === \"undefined\") {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Only update if this param is in the template\n\t\t\tif (!paramNames.includes(key)) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t`Parameter \"${key}\" is not defined in path template: ${fullTemplate}`,\n\t\t\t\t);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst newPath = buildFullPath({ [key]: value });\n\t\t\twindow.history.replaceState({}, \"\", newPath);\n\t\t},\n\n\t\tgetAllParams: (): Record<string, string> => {\n\t\t\treturn getCurrentParams();\n\t\t},\n\n\t\treplaceParams: (params: Record<string, string>): void => {\n\t\t\tif (typeof window === \"undefined\") {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Validate all params are in template\n\t\t\tfor (const key of Object.keys(params)) {\n\t\t\t\tif (!paramNames.includes(key)) {\n\t\t\t\t\tconsole.warn(\n\t\t\t\t\t\t`Parameter \"${key}\" is not defined in path template: ${fullTemplate}`,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst newPath = buildFullPath(params);\n\t\t\twindow.history.replaceState({}, \"\", newPath);\n\t\t},\n\t};\n}\n\n/**\n * Framework-agnostic path params adapter that reads initial params from props\n * Works with any framework that provides route params (Next.js, Remix, etc.)\n * Uses browser History API for navigation, making it framework-agnostic\n *\n * @param pathParams - Route params from your framework (can be a Promise in Next.js 15+)\n * @param config - Path configuration\n * @returns A UrlParamsAdapter that works with path segments\n *\n * @example\n * ```tsx\n * // Next.js example\n * export default function WizardPage({ params }: { params: Promise<{ id: string; page: string }> }) {\n *   const resolvedParams = use(params);\n *   const adapter = createPathParamsAdapterFromProps(\n *     resolvedParams,\n *     { template: \"/[id]/[page]\", basePath: \"/wizard\" }\n *   );\n *   return <Wizard graph={graph} config={{ urlParamsAdapter: adapter }} />;\n * }\n *\n * // Other frameworks (Remix, etc.)\n * export default function WizardPage({ params }: { params: { id: string; page: string } }) {\n *   const adapter = createPathParamsAdapterFromProps(\n *     params,\n *     { template: \"/[id]/[page]\", basePath: \"/wizard\" }\n *   );\n *   return <Wizard graph={graph} config={{ urlParamsAdapter: adapter }} />;\n * }\n * ```\n */\nexport function createPathParamsAdapterFromProps(\n\t_pathParams:\n\t\t| Record<string, string | string[]>\n\t\t| Promise<Record<string, string | string[]>>,\n\tconfig: PathConfig,\n): UrlParamsAdapter {\n\tconst fullTemplate = config.basePath\n\t\t? `${config.basePath}${config.template}`\n\t\t: config.template;\n\n\tconst paramNames = parsePathTemplate(fullTemplate);\n\n\t// Read params from the URL path directly (framework-agnostic)\n\t// The URL is always the source of truth, even on initial render\n\tconst getCurrentPath = (): string => {\n\t\tif (typeof window === \"undefined\") {\n\t\t\treturn \"\";\n\t\t}\n\t\treturn window.location.pathname;\n\t};\n\n\tconst getCurrentParamsFromUrl = (): Record<string, string> => {\n\t\tconst path = getCurrentPath();\n\t\treturn parsePath(path, fullTemplate);\n\t};\n\n\t// Always read from URL - the URL is the source of truth\n\tconst getParams = (): Record<string, string> => {\n\t\treturn getCurrentParamsFromUrl();\n\t};\n\n\tconst buildFullPath = (params: Record<string, string>): string => {\n\t\tconst current = getParams();\n\t\tconst mergedParams = { ...current, ...params };\n\t\treturn buildPath(fullTemplate, mergedParams);\n\t};\n\n\treturn {\n\t\tgetParam: (key: string): string | null => {\n\t\t\tconst params = getParams();\n\t\t\treturn params[key] || null;\n\t\t},\n\n\t\tsetParam: (key: string, value: string): void => {\n\t\t\tif (typeof window === \"undefined\") {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (!paramNames.includes(key)) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t`Parameter \"${key}\" is not defined in path template: ${fullTemplate}`,\n\t\t\t\t);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst newPath = buildFullPath({ [key]: value });\n\t\t\twindow.history.pushState({}, \"\", newPath);\n\t\t},\n\n\t\treplaceParam: (key: string, value: string): void => {\n\t\t\tif (typeof window === \"undefined\") {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (!paramNames.includes(key)) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t`Parameter \"${key}\" is not defined in path template: ${fullTemplate}`,\n\t\t\t\t);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst newPath = buildFullPath({ [key]: value });\n\t\t\twindow.history.replaceState({}, \"\", newPath);\n\t\t},\n\n\t\tgetAllParams: (): Record<string, string> => {\n\t\t\treturn { ...getParams() };\n\t\t},\n\n\t\treplaceParams: (params: Record<string, string>): void => {\n\t\t\tif (typeof window === \"undefined\") {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tfor (const key of Object.keys(params)) {\n\t\t\t\tif (!paramNames.includes(key)) {\n\t\t\t\t\tconsole.warn(\n\t\t\t\t\t\t`Parameter \"${key}\" is not defined in path template: ${fullTemplate}`,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst newPath = buildFullPath(params);\n\t\t\twindow.history.replaceState({}, \"\", newPath);\n\t\t},\n\t};\n}\n","import { getPagesInOrder } from \"@/wizard/graph\";\nimport type { WizardGraph, WizardState } from \"@/wizard/types\";\n\n/**\n * Session storage key prefix for wizard state\n */\nconst STORAGE_PREFIX = \"wizard:\";\n\n/**\n * Structure for storing page state in session storage\n */\ntype PageStateEntry = {\n\tpage: string;\n\tstate: WizardState;\n};\n\n/**\n * Manager for wizard state stored in session storage\n * Uses UUID-based storage with array structure: wizard:{uuid}: [{ page, state }, ...]\n */\nexport class WizardStateManager {\n\tprivate prefix: string;\n\n\tconstructor(prefix: string = STORAGE_PREFIX) {\n\t\tthis.prefix = prefix;\n\t}\n\n\t/**\n\t * Gets the storage key for a wizard UUID\n\t */\n\tprivate getStorageKey(uuid: string): string {\n\t\treturn `${this.prefix}${uuid}`;\n\t}\n\n\t/**\n\t * Gets all page state entries for a wizard UUID\n\t */\n\tprivate getPageStateEntries(uuid: string): PageStateEntry[] {\n\t\tif (typeof window === \"undefined\" || !window.sessionStorage) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst storageKey = this.getStorageKey(uuid);\n\t\tconst stored = window.sessionStorage.getItem(storageKey);\n\n\t\tif (!stored) {\n\t\t\treturn [];\n\t\t}\n\n\t\ttry {\n\t\t\treturn JSON.parse(stored) as PageStateEntry[];\n\t\t} catch (error) {\n\t\t\tconsole.warn(`Failed to parse state for UUID \"${uuid}\":`, error);\n\t\t\treturn [];\n\t\t}\n\t}\n\n\t/**\n\t * Saves all page state entries for a wizard UUID\n\t */\n\tprivate setPageStateEntries(uuid: string, entries: PageStateEntry[]): void {\n\t\tif (typeof window === \"undefined\" || !window.sessionStorage) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst storageKey = this.getStorageKey(uuid);\n\t\ttry {\n\t\t\twindow.sessionStorage.setItem(storageKey, JSON.stringify(entries));\n\t\t} catch (error) {\n\t\t\tconsole.error(`Failed to save state for UUID \"${uuid}\":`, error);\n\t\t}\n\t}\n\n\t/**\n\t * Pre-registers all expected state keys from the graph\n\t * This allows us to see all expected state upfront\n\t */\n\tpreRegisterState(graph: WizardGraph, uuid: string): void {\n\t\tif (typeof window === \"undefined\" || !window.sessionStorage) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst entries = this.getPageStateEntries(uuid);\n\t\tconst pages = getPagesInOrder(graph);\n\t\tconst existingPages = new Set(entries.map((e) => e.page));\n\n\t\t// Initialize entries for pages that don't exist yet\n\t\tfor (const page of pages) {\n\t\t\tif (!existingPages.has(page)) {\n\t\t\t\tentries.push({ page, state: {} });\n\t\t\t}\n\t\t}\n\n\t\t// Save the updated entries\n\t\tthis.setPageStateEntries(uuid, entries);\n\t}\n\n\t/**\n\t * Gets state for a specific page\n\t */\n\tgetState(uuid: string, page: string): WizardState {\n\t\tconst entries = this.getPageStateEntries(uuid);\n\t\tconst entry = entries.find((e) => e.page === page);\n\t\treturn entry?.state || {};\n\t}\n\n\t/**\n\t * Sets state for a specific page\n\t */\n\tsetState(uuid: string, page: string, key: string, value: unknown): void {\n\t\tconst entries = this.getPageStateEntries(uuid);\n\t\tlet entry = entries.find((e) => e.page === page);\n\n\t\tif (!entry) {\n\t\t\tentry = { page, state: {} };\n\t\t\tentries.push(entry);\n\t\t}\n\n\t\tentry.state[key] = value;\n\t\tthis.setPageStateEntries(uuid, entries);\n\t}\n\n\t/**\n\t * Sets multiple state values for a page at once\n\t */\n\tsetStateBatch(\n\t\tuuid: string,\n\t\tpage: string,\n\t\tupdates: Record<string, unknown>,\n\t): void {\n\t\tconst entries = this.getPageStateEntries(uuid);\n\t\tlet entry = entries.find((e) => e.page === page);\n\n\t\tif (!entry) {\n\t\t\tentry = { page, state: {} };\n\t\t\tentries.push(entry);\n\t\t}\n\n\t\tObject.assign(entry.state, updates);\n\t\tthis.setPageStateEntries(uuid, entries);\n\t}\n\n\t/**\n\t * Gets accumulated state from all pages in the graph\n\t */\n\tgetAllState(_graph: WizardGraph, uuid: string): WizardState {\n\t\tconst allState: WizardState = {};\n\t\tconst entries = this.getPageStateEntries(uuid);\n\n\t\t// Merge state from all pages (later pages override earlier ones)\n\t\tfor (const entry of entries) {\n\t\t\tObject.assign(allState, entry.state);\n\t\t}\n\n\t\treturn allState;\n\t}\n\n\t/**\n\t * Gets state for all pages up to and including the specified page\n\t */\n\tgetStateUpTo(_graph: WizardGraph, uuid: string, page: string): WizardState {\n\t\tconst allState: WizardState = {};\n\t\tconst entries = this.getPageStateEntries(uuid);\n\t\tconst pages = getPagesInOrder(_graph);\n\n\t\t// Only include pages up to the specified page\n\t\tfor (const p of pages) {\n\t\t\tconst entry = entries.find((e) => e.page === p);\n\t\t\tif (entry) {\n\t\t\t\tObject.assign(allState, entry.state);\n\t\t\t}\n\n\t\t\tif (p === page) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn allState;\n\t}\n\n\t/**\n\t * Checks if state exists for a specific UUID\n\t */\n\thasState(uuid: string): boolean {\n\t\tif (typeof window === \"undefined\" || !window.sessionStorage) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst storageKey = this.getStorageKey(uuid);\n\t\tconst stored = window.sessionStorage.getItem(storageKey);\n\t\treturn stored !== null && stored !== \"\";\n\t}\n\n\t/**\n\t * Clears all wizard state for a specific UUID\n\t */\n\tclearState(uuid: string): void {\n\t\tif (typeof window === \"undefined\" || !window.sessionStorage) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst storageKey = this.getStorageKey(uuid);\n\t\twindow.sessionStorage.removeItem(storageKey);\n\t}\n\n\t/**\n\t * Clears state for a specific page within a wizard UUID\n\t */\n\tclearPageState(uuid: string, page: string): void {\n\t\tconst entries = this.getPageStateEntries(uuid);\n\t\tconst filtered = entries.filter((e) => e.page !== page);\n\t\tthis.setPageStateEntries(uuid, filtered);\n\t}\n}\n\n/**\n * Default instance of WizardStateManager\n */\nexport const defaultStateManager = new WizardStateManager();\n","import { useCallback, useEffect, useState } from \"react\";\nimport type { UrlParamsAdapter } from \"@/wizard/types\";\n\n/**\n * Default browser-based URL params adapter\n */\nexport const browserUrlParamsAdapter: UrlParamsAdapter = {\n\tgetParam: (key: string): string | null => {\n\t\tif (typeof window === \"undefined\") {\n\t\t\treturn null;\n\t\t}\n\t\tconst params = new URLSearchParams(window.location.search);\n\t\treturn params.get(key);\n\t},\n\n\tsetParam: (key: string, value: string): void => {\n\t\tif (typeof window === \"undefined\") {\n\t\t\treturn;\n\t\t}\n\t\tconst url = new URL(window.location.href);\n\t\turl.searchParams.set(key, value);\n\t\twindow.history.pushState({}, \"\", url.toString());\n\t},\n\n\treplaceParam: (key: string, value: string): void => {\n\t\tif (typeof window === \"undefined\") {\n\t\t\treturn;\n\t\t}\n\t\tconst url = new URL(window.location.href);\n\t\turl.searchParams.set(key, value);\n\t\twindow.history.replaceState({}, \"\", url.toString());\n\t},\n\n\tgetAllParams: (): Record<string, string> => {\n\t\tif (typeof window === \"undefined\") {\n\t\t\treturn {};\n\t\t}\n\t\tconst params = new URLSearchParams(window.location.search);\n\t\tconst result: Record<string, string> = {};\n\t\tfor (const [key, value] of params.entries()) {\n\t\t\tresult[key] = value;\n\t\t}\n\t\treturn result;\n\t},\n\n\treplaceParams: (params: Record<string, string>): void => {\n\t\tif (typeof window === \"undefined\") {\n\t\t\treturn;\n\t\t}\n\t\tconst url = new URL(window.location.href);\n\t\t// Clear existing params\n\t\turl.search = \"\";\n\t\t// Set new params\n\t\tfor (const [key, value] of Object.entries(params)) {\n\t\t\turl.searchParams.set(key, value);\n\t\t}\n\t\twindow.history.replaceState({}, \"\", url.toString());\n\t},\n};\n\n/**\n * Hook for managing URL parameters in a framework-agnostic way\n */\nexport function useUrlParams(\n\tadapter: UrlParamsAdapter = browserUrlParamsAdapter,\n) {\n\tconst [params, setParams] = useState<Record<string, string>>(() =>\n\t\tadapter.getAllParams(),\n\t);\n\n\t// Sync with URL changes (browser back/forward) and when adapter changes\n\tuseEffect(() => {\n\t\tif (typeof window === \"undefined\") {\n\t\t\treturn;\n\t\t}\n\n\t\t// Re-read from current URL when adapter changes (e.g. after popstate + parent re-render)\n\t\tsetParams(adapter.getAllParams());\n\n\t\tconst handlePopState = () => {\n\t\t\tsetParams(adapter.getAllParams());\n\t\t};\n\n\t\twindow.addEventListener(\"popstate\", handlePopState);\n\t\treturn () => {\n\t\t\twindow.removeEventListener(\"popstate\", handlePopState);\n\t\t};\n\t}, [adapter]);\n\n\tconst getParam = useCallback(\n\t\t(key: string): string | null => {\n\t\t\treturn adapter.getParam(key);\n\t\t},\n\t\t[adapter],\n\t);\n\n\tconst setParam = useCallback(\n\t\t(key: string, value: string): void => {\n\t\t\tadapter.setParam(key, value);\n\t\t\tsetParams(adapter.getAllParams());\n\t\t},\n\t\t[adapter],\n\t);\n\n\tconst replaceParam = useCallback(\n\t\t(key: string, value: string): void => {\n\t\t\tadapter.replaceParam(key, value);\n\t\t\tsetParams(adapter.getAllParams());\n\t\t},\n\t\t[adapter],\n\t);\n\n\tconst getAllParams = useCallback((): Record<string, string> => {\n\t\treturn adapter.getAllParams();\n\t}, [adapter]);\n\n\tconst replaceParams = useCallback(\n\t\t(newParams: Record<string, string>): void => {\n\t\t\tadapter.replaceParams(newParams);\n\t\t\tsetParams(adapter.getAllParams());\n\t\t},\n\t\t[adapter],\n\t);\n\n\treturn {\n\t\tgetParam,\n\t\tsetParam,\n\t\treplaceParam,\n\t\tgetAllParams,\n\t\treplaceParams,\n\t\tparams,\n\t};\n}\n","import { useCallback, useEffect, useMemo, useRef, useState } from \"react\";\nimport {\n\tgetNextPage,\n\tgetNode,\n\tgetPreviousPage,\n\tshouldSkipStep,\n} from \"@/wizard/graph\";\nimport { Presenter } from \"@/wizard/Presenter\";\nimport { defaultStateManager, type WizardStateManager } from \"@/wizard/state\";\nimport type {\n\tComponentLoader,\n\tUrlParamsAdapter,\n\tWizardContextValue,\n\tWizardGraph,\n} from \"@/wizard/types\";\nimport { useUrlParams } from \"@/wizard/url-params\";\nimport { WizardContext } from \"@/wizard/WizardContext\";\n\n/**\n * Configuration options for the Wizard component\n */\nexport type WizardConfig = {\n\t/**\n\t * Optional URL params adapter (defaults to browser implementation)\n\t */\n\turlParamsAdapter?: UrlParamsAdapter;\n\n\t/**\n\t * Optional state manager (defaults to default instance)\n\t */\n\tstateManager?: WizardStateManager;\n\n\t/**\n\t * Optional URL parameter name for the current page (defaults to \"page\")\n\t */\n\tpageParamName?: string;\n\n\t/**\n\t * Optional URL parameter name for the wizard UUID (defaults to \"id\")\n\t */\n\tuuidParamName?: string;\n\n\t/**\n\t * Optional loading fallback for Presenter\n\t */\n\tloadingFallback?: React.ReactNode;\n\n\t/**\n\t * Optional unknown page fallback for Presenter\n\t */\n\tunknownPageFallback?: React.ReactNode;\n\n\t/**\n\t * Optional callback when page changes\n\t */\n\tonPageChange?: (page: string | null, previousPage: string | null) => void;\n\n\t/**\n\t * Map of page identifiers to component loaders\n\t * Each loader should return a promise that resolves to a component with a default export\n\t */\n\tcomponentLoaders?: Map<string, ComponentLoader>;\n};\n\n/**\n * Props for the Wizard component\n */\nexport type WizardProps = {\n\t/**\n\t * The wizard graph definition (nodes contain component loaders)\n\t */\n\tgraph: WizardGraph;\n\n\t/**\n\t * Optional configuration object\n\t */\n\tconfig?: WizardConfig;\n};\n\n/**\n * Main Wizard component that orchestrates graph navigation, state management, and URL params\n */\n/**\n * Generates a UUID and returns the last 5 characters (digits/letters)\n */\nfunction generateShortUuid(): string {\n\t// Generate a UUID and take the last 5 characters\n\t// Remove hyphens first to ensure we get 5 alphanumeric characters\n\tconst uuid = crypto.randomUUID().replace(/-/g, \"\");\n\treturn uuid.slice(-5);\n}\n\nexport function Wizard({ graph, config = {} }: WizardProps) {\n\tconst {\n\t\turlParamsAdapter,\n\t\tstateManager = defaultStateManager,\n\t\tpageParamName = \"page\",\n\t\tuuidParamName = \"id\",\n\t\tloadingFallback,\n\t\tunknownPageFallback,\n\t\tonPageChange,\n\t\tcomponentLoaders,\n\t} = config;\n\n\t// Build component loaders map from graph if not provided\n\tconst componentLoadersMap = useMemo(() => {\n\t\tif (componentLoaders) {\n\t\t\treturn componentLoaders;\n\t\t}\n\t\t// If not provided, create an empty map (users must provide componentLoaders)\n\t\treturn new Map<string, ComponentLoader>();\n\t}, [componentLoaders]);\n\tconst urlParams = useUrlParams(urlParamsAdapter);\n\n\t// Get or generate UUID (last 5 digits)\n\tconst [wizardUuid, setWizardUuid] = useState<string>(() => {\n\t\tconst existingUuid = urlParams.getParam(uuidParamName);\n\t\tif (existingUuid) {\n\t\t\treturn existingUuid;\n\t\t}\n\t\tconst newUuid = generateShortUuid();\n\t\t// Set it in URL if it doesn't exist\n\t\tif (typeof window !== \"undefined\") {\n\t\t\turlParams.setParam(uuidParamName, newUuid);\n\t\t}\n\t\treturn newUuid;\n\t});\n\n\t// Sync UUID with URL param\n\tuseEffect(() => {\n\t\tconst urlUuid = urlParams.getParam(uuidParamName);\n\t\tif (urlUuid && urlUuid !== wizardUuid) {\n\t\t\tsetWizardUuid(urlUuid);\n\t\t} else if (!urlUuid) {\n\t\t\turlParams.setParam(uuidParamName, wizardUuid);\n\t\t}\n\t}, [wizardUuid, uuidParamName, urlParams]);\n\n\t// Determine initial page - start with null to ensure validation completes before rendering\n\t// We'll validate in useEffect to ensure session storage is accessible\n\tconst [currentPage, setCurrentPage] = useState<string | null>(null);\n\n\t// Track if we're currently validating initial state (entry point + session storage check)\n\t// This prevents rendering until we've confirmed we're either on entry point or state exists\n\t// Always start with true - we'll validate in the effect\n\tconst [isValidating, setIsValidating] = useState(true);\n\n\t// Track if we're currently checking if a page should be skipped\n\tconst [isCheckingSkip, setIsCheckingSkip] = useState(false);\n\tconst skipCheckRef = useRef(false);\n\tconst hasInitializedRef = useRef(false);\n\n\t// State version counter to trigger re-computation of allState\n\tconst [stateVersion, setStateVersion] = useState(0);\n\n\t// Get accumulated state from all pages\n\t// We use stateVersion to force re-computation of allState\n\tconst allState = useMemo(() => {\n\t\t// Force dependency on stateVersion by using it in the computation\n\t\t// This ensures the memo recomputes when state updates\n\t\tconst _ = stateVersion;\n\t\treturn stateManager.getAllState(graph, wizardUuid);\n\t}, [graph, stateManager, wizardUuid, stateVersion]);\n\n\t// Early validation check: Ensure we're either on entry point or state exists\n\t// This runs first to prevent any rendering until validation is complete\n\tuseEffect(() => {\n\t\tif (!isValidating) {\n\t\t\treturn; // Validation already complete\n\t\t}\n\n\t\tconst urlPage = urlParams.getParam(pageParamName);\n\t\tconst entryPoint = graph.entryPoint || null;\n\t\tconst isEntryPoint = urlPage === entryPoint;\n\n\t\t// If we're on entry point or no page param, no validation needed (will go to entry point)\n\t\tif (isEntryPoint || !urlPage) {\n\t\t\tsetCurrentPage(urlPage || entryPoint);\n\t\t\tsetIsValidating(false);\n\t\t\treturn;\n\t\t}\n\n\t\t// Not on entry point - must check if state exists in session storage\n\t\t// Check if UUID exists in session storage\n\t\tconst uuidExists = stateManager.hasState(wizardUuid);\n\n\t\t// If not on entry point and no state exists, show expired\n\t\tif (!uuidExists) {\n\t\t\tsetCurrentPage(\"__expired__\");\n\t\t\tsetIsValidating(false);\n\t\t\treturn;\n\t\t}\n\n\t\t// State exists - check if page exists in graph\n\t\tif (!graph.nodes.has(urlPage)) {\n\t\t\tsetCurrentPage(\"__notfound__\");\n\t\t\tsetIsValidating(false);\n\t\t\treturn;\n\t\t}\n\n\t\t// Validation passes - page is valid and state exists\n\t\tsetCurrentPage(urlPage);\n\t\tsetIsValidating(false);\n\t}, [isValidating, urlParams, pageParamName, graph, wizardUuid, stateManager]);\n\n\t// Sync current page with URL param changes (browser back/forward)\n\t// URL is the source of truth - when URL changes, it drives what page is shown\n\t// Also validates UUID existence and page validity BEFORE pre-registering state\n\t// Run validation immediately on mount to ensure correct initial state\n\tuseEffect(() => {\n\t\t// Don't proceed if still validating - wait for validation to complete\n\t\tif (isValidating) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst urlPage = urlParams.params[pageParamName] ?? null;\n\t\tconst entryPoint = graph.entryPoint || null;\n\t\tconst isEntryPoint = urlPage === entryPoint;\n\n\t\t// Check if UUID exists in session storage BEFORE doing anything\n\t\tconst uuidExists = stateManager.hasState(wizardUuid);\n\n\t\t// Validate: UUID existence takes priority (only if not entry point)\n\t\t// For entry point, UUID doesn't need to exist (new wizard start)\n\t\tif (!uuidExists && urlPage && !isEntryPoint) {\n\t\t\t// UUID doesn't exist and not entry point - show expired (don't create state)\n\t\t\t// This takes priority over page existence check\n\t\t\tif (currentPage !== \"__expired__\") {\n\t\t\t\tsetCurrentPage(\"__expired__\");\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\t// UUID exists (or is entry point), now check if page exists in graph\n\t\tif (urlPage && !graph.nodes.has(urlPage)) {\n\t\t\t// UUID exists but page doesn't exist - show page not found (don't create state)\n\t\t\tif (currentPage !== \"__notfound__\") {\n\t\t\t\tsetCurrentPage(\"__notfound__\");\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\t// Validation passes - ensure currentPage matches URL page if it was set to error state initially\n\t\t// This handles the case where initial state validation didn't run properly\n\t\tif (\n\t\t\t(currentPage === \"__expired__\" || currentPage === \"__notfound__\") &&\n\t\t\turlPage &&\n\t\t\tgraph.nodes.has(urlPage)\n\t\t) {\n\t\t\t// Validation now passes, update to show the actual page\n\t\t\tsetCurrentPage(urlPage);\n\t\t}\n\n\t\t// If we're already showing an error page but validation passes, don't proceed\n\t\t// This prevents flicker when initial state was set correctly\n\t\tif (currentPage === \"__expired__\" || currentPage === \"__notfound__\") {\n\t\t\t// If validation now passes, we should show the actual page\n\t\t\t// But only if the URL page matches what we expect\n\t\t\tif (\n\t\t\t\turlPage &&\n\t\t\t\turlPage !== currentPage &&\n\t\t\t\tgraph.nodes.has(urlPage) &&\n\t\t\t\tuuidExists\n\t\t\t) {\n\t\t\t\t// Validation now passes, update to show the actual page\n\t\t\t\tsetCurrentPage(urlPage);\n\t\t\t} else {\n\t\t\t\t// Still invalid, keep error state (already set correctly)\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// Only pre-register state if validation passes and we haven't initialized yet\n\t\t// Pre-register if UUID doesn't exist AND (this is the entry point OR no page param)\n\t\t// This ensures we only create state for valid new wizard starts\n\t\tif (\n\t\t\t!hasInitializedRef.current &&\n\t\t\t!uuidExists &&\n\t\t\t(isEntryPoint || !urlPage)\n\t\t) {\n\t\t\tstateManager.preRegisterState(graph, wizardUuid);\n\t\t\thasInitializedRef.current = true;\n\t\t\t// Trigger a re-render after pre-registration to load any existing state\n\t\t\tsetStateVersion((prev) => prev + 1);\n\t\t} else if (uuidExists) {\n\t\t\t// If UUID exists, mark as initialized (state was created in a previous session)\n\t\t\thasInitializedRef.current = true;\n\t\t}\n\n\t\t// If URL has a page param and it's different from current page\n\t\tif (urlPage && urlPage !== currentPage && graph.nodes.has(urlPage)) {\n\t\t\t// Check if the URL page should be skipped (handles browser back/forward landing on skipped pages)\n\t\t\tif (shouldSkipStep(graph, urlPage, allState)) {\n\t\t\t\t// Determine direction: if urlPage is the previous page from current, we're going back\n\t\t\t\tconst prevFromCurrent = currentPage\n\t\t\t\t\t? getPreviousPage(graph, currentPage, allState)\n\t\t\t\t\t: null;\n\t\t\t\tconst isGoingBack = prevFromCurrent === urlPage;\n\n\t\t\t\t// Get the appropriate non-skipped page based on direction\n\t\t\t\tconst targetPage = isGoingBack\n\t\t\t\t\t? getPreviousPage(graph, urlPage, allState)\n\t\t\t\t\t: getNextPage(graph, urlPage, allState);\n\n\t\t\t\tif (targetPage) {\n\t\t\t\t\t// Replace the skipped page in URL with the appropriate non-skipped page\n\t\t\t\t\turlParams.replaceParam(pageParamName, targetPage);\n\t\t\t\t\tsetCurrentPage(targetPage);\n\t\t\t\t\tonPageChange?.(targetPage, currentPage);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Normal navigation - page is not skipped, URL drives the state\n\t\t\t\tsetCurrentPage(urlPage);\n\t\t\t\tonPageChange?.(urlPage, currentPage);\n\t\t\t}\n\t\t} else if (!urlPage) {\n\t\t\t// If URL has no page param, sync to entry point\n\t\t\tif (entryPoint && entryPoint !== currentPage) {\n\t\t\t\tsetCurrentPage(entryPoint);\n\t\t\t\turlParams.setParam(pageParamName, entryPoint);\n\t\t\t} else if (!entryPoint && currentPage) {\n\t\t\t\t// No entry point and no URL param, clear current page\n\t\t\t\tsetCurrentPage(null);\n\t\t\t}\n\t\t}\n\t}, [\n\t\turlParams.params,\n\t\tgraph,\n\t\tcurrentPage,\n\t\tallState,\n\t\tonPageChange,\n\t\tpageParamName,\n\t\turlParams,\n\t\tstateManager,\n\t\twizardUuid,\n\t\tisValidating,\n\t]);\n\n\t// Check if current page should be skipped and navigate if needed\n\t// This runs when a page loads to handle conditional skipping\n\tuseEffect(() => {\n\t\t// Reset skip check ref when page changes\n\t\tskipCheckRef.current = false;\n\n\t\tif (!currentPage) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Check if current page should be skipped\n\t\tif (shouldSkipStep(graph, currentPage, allState)) {\n\t\t\tsetIsCheckingSkip(true);\n\t\t\tskipCheckRef.current = true;\n\n\t\t\t// Find next non-skipped page\n\t\t\tconst nextPage = getNextPage(graph, currentPage, allState);\n\n\t\t\tif (nextPage) {\n\t\t\t\t// Replace URL (don't add to history) since we're skipping\n\t\t\t\turlParams.replaceParam(pageParamName, nextPage);\n\t\t\t\tsetCurrentPage(nextPage);\n\t\t\t\tonPageChange?.(nextPage, currentPage);\n\t\t\t}\n\n\t\t\tsetIsCheckingSkip(false);\n\t\t}\n\t}, [currentPage, graph, allState, pageParamName, urlParams, onPageChange]);\n\n\t// Navigation functions\n\tconst goToNext = useCallback(() => {\n\t\tif (!currentPage) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst nextPage = getNextPage(graph, currentPage, allState);\n\t\tif (!nextPage) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst previousPage = currentPage;\n\n\t\t// Check if we're skipping any steps\n\t\t// If the next page is different from what would be the direct next,\n\t\t// we're skipping steps\n\t\tconst currentNode = getNode(graph, currentPage);\n\t\tlet directNext: string | null = null;\n\t\tif (currentNode) {\n\t\t\tconst resolved = currentNode.nextPage;\n\t\t\tif (typeof resolved === \"string\") {\n\t\t\t\tdirectNext = resolved;\n\t\t\t} else if (Array.isArray(resolved) && resolved.length > 0) {\n\t\t\t\tdirectNext = resolved[0];\n\t\t\t} else if (typeof resolved === \"function\") {\n\t\t\t\tconst funcResult = resolved(allState);\n\t\t\t\tif (typeof funcResult === \"string\") {\n\t\t\t\t\tdirectNext = funcResult;\n\t\t\t\t} else if (Array.isArray(funcResult) && funcResult.length > 0) {\n\t\t\t\t\tdirectNext = funcResult[0];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// If nextPage is different from directNext, we skipped steps\n\t\tconst isSkipping = directNext !== null && directNext !== nextPage;\n\n\t\t// Use replaceParam if skipping (to remove skipped steps from history)\n\t\t// Otherwise use setParam (normal navigation adds to history)\n\t\tif (isSkipping) {\n\t\t\t// When skipping, replace current entry to avoid skipped pages in history\n\t\t\turlParams.replaceParam(pageParamName, nextPage);\n\t\t} else {\n\t\t\t// Normal navigation - add to history\n\t\t\turlParams.setParam(pageParamName, nextPage);\n\t\t}\n\n\t\tsetCurrentPage(nextPage);\n\t\tonPageChange?.(nextPage, previousPage);\n\t}, [graph, currentPage, allState, onPageChange, pageParamName, urlParams]);\n\n\tconst goToPrevious = useCallback(() => {\n\t\t// Use browser history back - the history is already correct because skipped pages\n\t\t// are replaced with replaceParam, so history.back() will go to the correct previous page\n\t\tif (typeof window !== \"undefined\" && window.history.length > 1) {\n\t\t\twindow.history.back();\n\t\t}\n\t}, []);\n\n\tconst goToPage = useCallback(\n\t\t(page: string) => {\n\t\t\tif (!graph.nodes.has(page)) {\n\t\t\t\tconsole.warn(`Page \"${page}\" does not exist in graph`);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst previousPage = currentPage;\n\n\t\t\tsetCurrentPage(page);\n\t\t\turlParams.setParam(pageParamName, page);\n\t\t\tonPageChange?.(page, previousPage);\n\t\t},\n\t\t[graph, currentPage, onPageChange, pageParamName, urlParams],\n\t);\n\n\tconst skipToPage = useCallback(\n\t\t(page: string) => {\n\t\t\tif (!graph.nodes.has(page)) {\n\t\t\t\tconsole.warn(`Page \"${page}\" does not exist in graph`);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst previousPage = currentPage;\n\n\t\t\tsetCurrentPage(page);\n\t\t\turlParams.replaceParam(pageParamName, page);\n\t\t\tonPageChange?.(page, previousPage);\n\t\t},\n\t\t[graph, currentPage, onPageChange, pageParamName, urlParams],\n\t);\n\n\t// Skip current page and navigate to next non-skipped page\n\t// This can be called from within a page component after loading\n\tconst skipCurrentPage = useCallback(() => {\n\t\tif (!currentPage) {\n\t\t\treturn;\n\t\t}\n\n\t\tsetIsCheckingSkip(true);\n\t\tskipCheckRef.current = true;\n\n\t\t// Find next non-skipped page\n\t\tconst nextPage = getNextPage(graph, currentPage, allState);\n\n\t\tif (nextPage) {\n\t\t\t// Replace URL (don't add to history) since we're skipping\n\t\t\t// This ensures skipped pages don't appear in browser history\n\t\t\turlParams.replaceParam(pageParamName, nextPage);\n\t\t\tsetCurrentPage(nextPage);\n\t\t\tonPageChange?.(nextPage, currentPage);\n\t\t}\n\n\t\tsetIsCheckingSkip(false);\n\t}, [currentPage, graph, allState, pageParamName, urlParams, onPageChange]);\n\n\t// Complete wizard and clear state from session storage\n\t// User is responsible for handling navigation/redirect after calling this\n\tconst completeWizard = useCallback(() => {\n\t\tstateManager.clearState(wizardUuid);\n\t}, [stateManager, wizardUuid]);\n\n\t// State update functions\n\tconst updateState = useCallback(\n\t\t(key: string, value: unknown) => {\n\t\t\tif (!currentPage) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tstateManager.setState(wizardUuid, currentPage, key, value);\n\t\t\t// Trigger re-computation of allState\n\t\t\tsetStateVersion((prev) => prev + 1);\n\t\t},\n\t\t[currentPage, stateManager, wizardUuid],\n\t);\n\n\tconst updateStateBatch = useCallback(\n\t\t(updates: Record<string, unknown>) => {\n\t\t\tif (!currentPage) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tstateManager.setStateBatch(wizardUuid, currentPage, updates);\n\t\t\t// Trigger re-computation of allState\n\t\t\tsetStateVersion((prev) => prev + 1);\n\t\t},\n\t\t[currentPage, stateManager, wizardUuid],\n\t);\n\n\tconst getPageState = useCallback(\n\t\t(page: string) => {\n\t\t\treturn stateManager.getState(wizardUuid, page);\n\t\t},\n\t\t[stateManager, wizardUuid],\n\t);\n\n\t// Helper functions\n\tconst getCurrentNode = useCallback(() => {\n\t\tif (!currentPage) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn getNode(graph, currentPage);\n\t}, [graph, currentPage]);\n\n\tconst getNodeByPage = useCallback(\n\t\t(page: string) => {\n\t\t\treturn getNode(graph, page);\n\t\t},\n\t\t[graph],\n\t);\n\n\tconst hasNext = useCallback(() => {\n\t\tif (!currentPage) {\n\t\t\treturn false;\n\t\t}\n\t\treturn getNextPage(graph, currentPage, allState) !== null;\n\t}, [graph, currentPage, allState]);\n\n\tconst hasPrevious = useCallback(() => {\n\t\tif (!currentPage) {\n\t\t\treturn false;\n\t\t}\n\t\t// Check if there's browser history to go back to\n\t\tif (typeof window !== \"undefined\" && window.history.length > 1) {\n\t\t\treturn true;\n\t\t}\n\t\t// Fallback to graph-based check\n\t\treturn getPreviousPage(graph, currentPage, allState) !== null;\n\t}, [graph, currentPage, allState]);\n\n\t// Build context value\n\tconst contextValue: WizardContextValue = useMemo(\n\t\t() => ({\n\t\t\tcurrentPage,\n\t\t\tstate: allState,\n\t\t\tgoToNext,\n\t\t\tgoToPrevious,\n\t\t\tgoToPage,\n\t\t\tskipToPage,\n\t\t\tupdateState,\n\t\t\tupdateStateBatch,\n\t\t\tgetPageState,\n\t\t\tgetCurrentNode,\n\t\t\tgetNode: getNodeByPage,\n\t\t\thasNext,\n\t\t\thasPrevious,\n\t\t\tskipCurrentPage,\n\t\t\tcompleteWizard,\n\t\t\tgetUrlParam: urlParams.getParam,\n\t\t\tgetAllUrlParams: urlParams.getAllParams,\n\t\t\turlParams: urlParams.params,\n\t\t}),\n\t\t[\n\t\t\tcurrentPage,\n\t\t\tallState,\n\t\t\tgoToNext,\n\t\t\tgoToPrevious,\n\t\t\tgoToPage,\n\t\t\tskipToPage,\n\t\t\tupdateState,\n\t\t\tupdateStateBatch,\n\t\t\tgetPageState,\n\t\t\tgetCurrentNode,\n\t\t\tgetNodeByPage,\n\t\t\thasNext,\n\t\t\thasPrevious,\n\t\t\tskipCurrentPage,\n\t\t\tcompleteWizard,\n\t\t\turlParams,\n\t\t],\n\t);\n\n\tconst currentNode = getCurrentNode();\n\n\t// Don't render anything while validating initial state (entry point + session storage check)\n\t// This prevents flicker when navigating to a non-entry-point page without state\n\tif (isValidating) {\n\t\treturn null;\n\t}\n\n\t// Show loader if we're checking if page should be skipped\n\tif (isCheckingSkip) {\n\t\treturn (\n\t\t\t<WizardContext.Provider value={contextValue}>\n\t\t\t\t{loadingFallback || <div />}\n\t\t\t</WizardContext.Provider>\n\t\t);\n\t}\n\n\treturn (\n\t\t<WizardContext.Provider value={contextValue}>\n\t\t\t<Presenter\n\t\t\t\tpage={currentPage}\n\t\t\t\tnode={currentNode}\n\t\t\t\tcomponentLoaders={componentLoadersMap}\n\t\t\t\tloadingFallback={loadingFallback}\n\t\t\t\tunknownPageFallback={unknownPageFallback}\n\t\t\t/>\n\t\t</WizardContext.Provider>\n\t);\n}\n"],"mappings":";AAKO,SAAS,oBAAiC;AAChD,SAAO;AAAA,IACN,OAAO,oBAAI,IAAwB;AAAA,EACpC;AACD;AAKO,SAAS,aAAa,OAAoB,MAAwB;AACxE,MAAI,MAAM,MAAM,IAAI,KAAK,WAAW,GAAG;AACtC,UAAM,IAAI;AAAA,MACT,0BAA0B,KAAK,WAAW;AAAA,IAC3C;AAAA,EACD;AAEA,QAAM,MAAM,IAAI,KAAK,aAAa,IAAI;AAGtC,MAAI,CAAC,MAAM,YAAY;AACtB,UAAM,aAAa,KAAK;AAAA,EACzB;AACD;AAMO,SAAS,2BACf,OACA,YACc;AACd,QAAM,QAAQ,kBAAkB;AAEhC,aAAW,QAAQ,OAAO;AACzB,iBAAa,OAAO,IAAI;AAAA,EACzB;AAGA,MAAI,YAAY;AACf,QAAI,CAAC,MAAM,MAAM,IAAI,UAAU,GAAG;AACjC,YAAM,IAAI,MAAM,gBAAgB,UAAU,2BAA2B;AAAA,IACtE;AACA,UAAM,aAAa;AAAA,EACpB;AAEA,SAAO;AACR;AAKO,SAAS,QACf,OACA,MACyB;AACzB,SAAO,MAAM,MAAM,IAAI,IAAI;AAC5B;AAKO,SAAS,eACf,OACA,MACA,OACU;AACV,QAAM,OAAO,QAAQ,OAAO,IAAI;AAChC,MAAI,CAAC,MAAM;AACV,WAAO;AAAA,EACR;AAEA,MAAI,KAAK,YAAY;AACpB,WAAO,KAAK,WAAW,KAAK;AAAA,EAC7B;AAEA,SAAO;AACR;AAKO,SAAS,gBACf,MACA,OAC2B;AAC3B,MAAI,CAAC,KAAK,UAAU;AACnB,WAAO;AAAA,EACR;AAGA,MAAI,OAAO,KAAK,aAAa,YAAY;AACxC,WAAO,KAAK,SAAS,KAAK;AAAA,EAC3B;AAGA,SAAO,KAAK;AACb;AAKO,SAAS,sBACf,OACA,MACA,OACA,UAAuB,oBAAI,IAAI,GACf;AAEhB,MAAI,QAAQ,IAAI,IAAI,GAAG;AACtB,YAAQ,KAAK,8CAA8C,IAAI,GAAG;AAClE,WAAO;AAAA,EACR;AACA,UAAQ,IAAI,IAAI;AAGhB,MAAI,eAAe,OAAO,MAAM,KAAK,GAAG;AACvC,UAAM,OAAO,QAAQ,OAAO,IAAI;AAChC,QAAI,CAAC,MAAM;AACV,aAAO;AAAA,IACR;AAEA,UAAM,OAAO,gBAAgB,MAAM,KAAK;AACxC,QAAI,SAAS,MAAM;AAClB,aAAO;AAAA,IACR;AAGA,UAAM,WAAW,MAAM,QAAQ,IAAI,IAAI,KAAK,CAAC,IAAI;AAEjD,QAAI,CAAC,YAAY,CAAC,MAAM,MAAM,IAAI,QAAQ,GAAG;AAC5C,aAAO;AAAA,IACR;AAGA,WAAO,sBAAsB,OAAO,UAAU,OAAO,OAAO;AAAA,EAC7D;AAGA,SAAO;AACR;AAMO,SAAS,YACf,OACA,aACA,OACgB;AAChB,QAAM,cAAc,QAAQ,OAAO,WAAW;AAC9C,MAAI,CAAC,aAAa;AACjB,WAAO;AAAA,EACR;AAEA,QAAM,OAAO,gBAAgB,aAAa,KAAK;AAE/C,MAAI,SAAS,MAAM;AAClB,WAAO;AAAA,EACR;AAGA,QAAM,WAAW,MAAM,QAAQ,IAAI,IAChC,KAAK,SAAS,IACb,KAAK,CAAC,IACN,OACD;AAEH,MAAI,CAAC,UAAU;AACd,WAAO;AAAA,EACR;AAGA,MAAI,CAAC,MAAM,MAAM,IAAI,QAAQ,GAAG;AAC/B,YAAQ,KAAK,cAAc,QAAQ,2BAA2B;AAC9D,WAAO;AAAA,EACR;AAGA,SAAO,sBAAsB,OAAO,UAAU,KAAK;AACpD;AAKO,SAAS,gBACf,OACA,aACA,OACW;AACX,QAAM,cAAc,QAAQ,OAAO,WAAW;AAC9C,MAAI,CAAC,aAAa;AACjB,WAAO,CAAC;AAAA,EACT;AAEA,QAAM,OAAO,gBAAgB,aAAa,KAAK;AAE/C,MAAI,SAAS,MAAM;AAClB,WAAO,CAAC;AAAA,EACT;AAEA,MAAI,MAAM,QAAQ,IAAI,GAAG;AAExB,WAAO,KAAK,OAAO,CAAC,SAAS,MAAM,MAAM,IAAI,IAAI,CAAC;AAAA,EACnD;AAGA,MAAI,MAAM,MAAM,IAAI,IAAI,GAAG;AAC1B,WAAO,CAAC,IAAI;AAAA,EACb;AAEA,SAAO,CAAC;AACT;AAKO,SAAS,0BACf,OACA,MACA,OACA,UAAuB,oBAAI,IAAI,GACf;AAEhB,MAAI,QAAQ,IAAI,IAAI,GAAG;AACtB,YAAQ,KAAK,8CAA8C,IAAI,GAAG;AAClE,WAAO;AAAA,EACR;AACA,UAAQ,IAAI,IAAI;AAEhB,QAAM,OAAO,QAAQ,OAAO,IAAI;AAChC,MAAI,CAAC,MAAM;AACV,WAAO;AAAA,EACR;AAEA,MAAI,CAAC,KAAK,sBAAsB;AAC/B,WAAO;AAAA,EACR;AAGA,MAAI,CAAC,MAAM,MAAM,IAAI,KAAK,oBAAoB,GAAG;AAChD,YAAQ;AAAA,MACP,kBAAkB,KAAK,oBAAoB;AAAA,IAC5C;AACA,WAAO;AAAA,EACR;AAGA,MAAI,eAAe,OAAO,KAAK,sBAAsB,KAAK,GAAG;AAE5D,WAAO;AAAA,MACN;AAAA,MACA,KAAK;AAAA,MACL;AAAA,MACA;AAAA,IACD;AAAA,EACD;AAGA,SAAO,KAAK;AACb;AAMO,SAAS,gBACf,OACA,aACA,OACgB;AAChB,QAAM,cAAc,QAAQ,OAAO,WAAW;AAC9C,MAAI,CAAC,aAAa;AACjB,WAAO;AAAA,EACR;AAEA,MAAI,CAAC,YAAY,sBAAsB;AACtC,WAAO;AAAA,EACR;AAGA,MAAI,CAAC,MAAM,MAAM,IAAI,YAAY,oBAAoB,GAAG;AACvD,YAAQ;AAAA,MACP,kBAAkB,YAAY,oBAAoB;AAAA,IACnD;AACA,WAAO;AAAA,EACR;AAGA,SAAO,0BAA0B,OAAO,aAAa,KAAK;AAC3D;AAKO,SAAS,cAAc,OAG5B;AACD,QAAM,SAAmB,CAAC;AAG1B,MAAI,MAAM,cAAc,CAAC,MAAM,MAAM,IAAI,MAAM,UAAU,GAAG;AAC3D,WAAO,KAAK,gBAAgB,MAAM,UAAU,2BAA2B;AAAA,EACxE;AAGA,aAAW,CAAC,MAAM,IAAI,KAAK,MAAM,MAAM,QAAQ,GAAG;AAEjD,QACC,KAAK,wBACL,CAAC,MAAM,MAAM,IAAI,KAAK,oBAAoB,GACzC;AACD,aAAO;AAAA,QACN,SAAS,IAAI,4CAA4C,KAAK,oBAAoB;AAAA,MACnF;AAAA,IACD;AAGA,QAAI,KAAK,YAAY,OAAO,KAAK,aAAa,YAAY;AACzD,YAAM,YAAY,MAAM,QAAQ,KAAK,QAAQ,IAC1C,KAAK,WACL,CAAC,KAAK,QAAQ;AACjB,iBAAW,YAAY,WAAW;AACjC,YAAI,CAAC,MAAM,MAAM,IAAI,QAAQ,GAAG;AAC/B,iBAAO;AAAA,YACN,SAAS,IAAI,wCAAwC,QAAQ;AAAA,UAC9D;AAAA,QACD;AAAA,MACD;AAAA,IACD;AAAA,EACD;AAEA,SAAO;AAAA,IACN,OAAO,OAAO,WAAW;AAAA,IACzB;AAAA,EACD;AACD;AAMO,SAAS,gBAAgB,OAA8B;AAC7D,QAAM,UAAU,oBAAI,IAAY;AAChC,QAAM,SAAmB,CAAC;AAE1B,WAAS,MAAM,MAAc;AAC5B,QAAI,QAAQ,IAAI,IAAI,GAAG;AACtB;AAAA,IACD;AAEA,YAAQ,IAAI,IAAI;AAChB,UAAM,OAAO,MAAM,MAAM,IAAI,IAAI;AACjC,QAAI,CAAC,MAAM;AACV;AAAA,IACD;AAGA,QAAI,KAAK,sBAAsB;AAC9B,YAAM,KAAK,oBAAoB;AAAA,IAChC;AAEA,WAAO,KAAK,IAAI;AAGhB,QAAI,KAAK,YAAY,OAAO,KAAK,aAAa,YAAY;AACzD,YAAM,YAAY,MAAM,QAAQ,KAAK,QAAQ,IAC1C,KAAK,WACL,CAAC,KAAK,QAAQ;AACjB,iBAAW,YAAY,WAAW;AACjC,cAAM,QAAQ;AAAA,MACf;AAAA,IACD;AAAA,EACD;AAGA,MAAI,MAAM,YAAY;AACrB,UAAM,MAAM,UAAU;AAAA,EACvB;AAGA,aAAW,QAAQ,MAAM,MAAM,KAAK,GAAG;AACtC,QAAI,CAAC,QAAQ,IAAI,IAAI,GAAG;AACvB,YAAM,IAAI;AAAA,IACX;AAAA,EACD;AAEA,SAAO;AACR;;;ACzYA,SAAS,mBAAmB;;;ACA5B,SAAS,eAAe,kBAAkB;AAMnC,IAAM,gBAAgB,cAAyC,IAAI;AAMnE,SAAS,mBAAuC;AACtD,QAAM,UAAU,WAAW,aAAa;AACxC,MAAI,CAAC,SAAS;AACb,UAAM,IAAI,MAAM,yDAAyD;AAAA,EAC1E;AACA,SAAO;AACR;;;ADLO,SAAS,YAA6B;AAC5C,QAAM,MAAM,iBAAiB;AAE7B,QAAM,WAAW;AAAA,IAChB,CAAc,QAAgB;AAC7B,YAAM,QAAS,IAAI,MAAM,GAAG,KAAuB;AACnD,YAAM,WAAW,CAAC,aAAgB,IAAI,YAAY,KAAK,QAAQ;AAC/D,aAAO,CAAC,OAAO,QAAQ;AAAA,IACxB;AAAA,IACA,CAAC,IAAI,OAAO,IAAI,WAAW;AAAA,EAC5B;AAEA,SAAO;AAAA,IACN,GAAG;AAAA,IACH;AAAA,IACA,SAAS,IAAI,QAAQ;AAAA,IACrB,aAAa,IAAI,YAAY;AAAA,EAC9B;AACD;;;AEjCA,SAAS,MAAM,UAAU,eAAe;AAuCtC,SAiDQ,UAjDR,KAqDE,YArDF;AAFF,IAAM,yBAAyB,MAC9B,oBAAC,SAAI,WAAU,wCACd,8BAAC,SAAI,WAAU,yBAAwB,wBAAU,GAClD;AAQM,SAAS,UAAU;AAAA,EACzB;AAAA,EACA;AAAA,EACA;AAAA,EACA,kBAAkB,oBAAC,0BAAuB;AAAA,EAC1C;AACD,GAAmB;AAElB,QAAM,YAAY,QAAQ,MAAM;AAC/B,QAAI,CAAC,MAAM;AACV,aAAO;AAAA,IACR;AAEA,UAAM,SAAS,iBAAiB,IAAI,IAAI;AACxC,QAAI,CAAC,QAAQ;AACZ,aAAO;AAAA,IACR;AAGA,WAAO,KAAK,MAAM;AAAA,EACnB,GAAG,CAAC,MAAM,gBAAgB,CAAC;AAG3B,MAAI,SAAS,iBAAiB,SAAS,gBAAgB;AACtD,QAAI,CAAC,WAAW;AACf,aAAO;AAAA,IACR;AACA,WACC,oBAAC,YAAS,UAAU,iBACnB,8BAAC,aAAU,GACZ;AAAA,EAEF;AAEA,MAAI,CAAC,QAAQ,CAAC,MAAM;AACnB,WAAO;AAAA,EACR;AAEA,MAAI,CAAC,WAAW;AACf,QAAI,qBAAqB;AACxB,aAAO,gCAAG,+BAAoB;AAAA,IAC/B;AACA,WACC,oBAAC,SAAI,WAAU,wCACd,+BAAC,SAAI,WAAU,oBAAmB;AAAA;AAAA,MAAe;AAAA,OAAK,GACvD;AAAA,EAEF;AAEA,SACC,oBAAC,YAAS,UAAU,iBACnB,8BAAC,aAAU,GACZ;AAEF;;;AC3EA,SAAS,kBAAkB,UAA4B;AACtD,QAAM,UAAU,SAAS,MAAM,eAAe;AAC9C,MAAI,CAAC,SAAS;AACb,WAAO,CAAC;AAAA,EACT;AACA,SAAO,QAAQ,IAAI,CAAC,UAAU,MAAM,MAAM,GAAG,EAAE,CAAC;AACjD;AAOA,SAAS,UAAU,UAAkB,QAAwC;AAC5E,MAAI,OAAO;AACX,aAAW,CAAC,KAAK,KAAK,KAAK,OAAO,QAAQ,MAAM,GAAG;AAClD,WAAO,KAAK,QAAQ,IAAI,GAAG,KAAK,mBAAmB,KAAK,CAAC;AAAA,EAC1D;AACA,SAAO;AACR;AAOA,SAAS,UAAU,MAAc,UAA0C;AAC1E,QAAM,SAAiC,CAAC;AACxC,QAAM,aAAa,kBAAkB,QAAQ;AAE7C,MAAI,WAAW,WAAW,GAAG;AAC5B,WAAO;AAAA,EACR;AAIA,QAAM,UAAU,SACd,QAAQ,iBAAiB,SAAS,EAClC,QAAQ,OAAO,KAAK;AAItB,QAAM,QAAQ,IAAI,OAAO,GAAG,OAAO,GAAG;AACtC,QAAM,UAAU,KAAK,MAAM,KAAK;AAEhC,MAAI,SAAS;AAEZ,aAAS,IAAI,GAAG,IAAI,WAAW,QAAQ,KAAK;AAC3C,YAAM,QAAQ,QAAQ,IAAI,CAAC;AAC3B,UAAI,OAAO;AACV,eAAO,WAAW,CAAC,CAAC,IAAI,mBAAmB,KAAK;AAAA,MACjD;AAAA,IACD;AAAA,EACD;AAEA,SAAO;AACR;AAiBO,SAAS,wBAAwB,QAAsC;AAC7E,QAAM,eAAe,OAAO,WACzB,GAAG,OAAO,QAAQ,GAAG,OAAO,QAAQ,KACpC,OAAO;AAEV,QAAM,aAAa,kBAAkB,YAAY;AAEjD,QAAM,iBAAiB,MAAc;AACpC,QAAI,OAAO,WAAW,aAAa;AAClC,aAAO;AAAA,IACR;AACA,WAAO,OAAO,SAAS;AAAA,EACxB;AAEA,QAAM,mBAAmB,MAA8B;AACtD,UAAM,OAAO,eAAe;AAC5B,WAAO,UAAU,MAAM,YAAY;AAAA,EACpC;AAEA,QAAM,gBAAgB,CAAC,WAA2C;AAEjE,UAAM,gBAAgB,iBAAiB;AACvC,UAAM,eAAe,EAAE,GAAG,eAAe,GAAG,OAAO;AAGnD,eAAW,aAAa,YAAY;AACnC,UAAI,CAAC,aAAa,SAAS,GAAG;AAE7B,cAAM,eAAe,iBAAiB,EAAE,SAAS;AACjD,YAAI,cAAc;AACjB,uBAAa,SAAS,IAAI;AAAA,QAC3B;AAAA,MACD;AAAA,IACD;AAEA,UAAM,UAAU,UAAU,cAAc,YAAY;AAIpD,UAAM,cAAc,eAAe;AACnC,UAAM,gBAAgB,YAAY,QAAQ,aAAa,MAAM,GAAG,EAAE,CAAC,CAAC;AACpE,QAAI,gBAAgB,GAAG;AAEtB,YAAM,SAAS,YAAY,MAAM,GAAG,aAAa;AACjD,aAAO,SAAS;AAAA,IACjB;AAEA,WAAO;AAAA,EACR;AAEA,SAAO;AAAA,IACN,UAAU,CAAC,QAA+B;AACzC,YAAM,SAAS,iBAAiB;AAChC,aAAO,OAAO,GAAG,KAAK;AAAA,IACvB;AAAA,IAEA,UAAU,CAAC,KAAa,UAAwB;AAC/C,UAAI,OAAO,WAAW,aAAa;AAClC;AAAA,MACD;AAGA,UAAI,CAAC,WAAW,SAAS,GAAG,GAAG;AAC9B,gBAAQ;AAAA,UACP,cAAc,GAAG,sCAAsC,YAAY;AAAA,QACpE;AACA;AAAA,MACD;AAEA,YAAM,UAAU,cAAc,EAAE,CAAC,GAAG,GAAG,MAAM,CAAC;AAC9C,aAAO,QAAQ,UAAU,CAAC,GAAG,IAAI,OAAO;AAAA,IACzC;AAAA,IAEA,cAAc,CAAC,KAAa,UAAwB;AACnD,UAAI,OAAO,WAAW,aAAa;AAClC;AAAA,MACD;AAGA,UAAI,CAAC,WAAW,SAAS,GAAG,GAAG;AAC9B,gBAAQ;AAAA,UACP,cAAc,GAAG,sCAAsC,YAAY;AAAA,QACpE;AACA;AAAA,MACD;AAEA,YAAM,UAAU,cAAc,EAAE,CAAC,GAAG,GAAG,MAAM,CAAC;AAC9C,aAAO,QAAQ,aAAa,CAAC,GAAG,IAAI,OAAO;AAAA,IAC5C;AAAA,IAEA,cAAc,MAA8B;AAC3C,aAAO,iBAAiB;AAAA,IACzB;AAAA,IAEA,eAAe,CAAC,WAAyC;AACxD,UAAI,OAAO,WAAW,aAAa;AAClC;AAAA,MACD;AAGA,iBAAW,OAAO,OAAO,KAAK,MAAM,GAAG;AACtC,YAAI,CAAC,WAAW,SAAS,GAAG,GAAG;AAC9B,kBAAQ;AAAA,YACP,cAAc,GAAG,sCAAsC,YAAY;AAAA,UACpE;AAAA,QACD;AAAA,MACD;AAEA,YAAM,UAAU,cAAc,MAAM;AACpC,aAAO,QAAQ,aAAa,CAAC,GAAG,IAAI,OAAO;AAAA,IAC5C;AAAA,EACD;AACD;AAiCO,SAAS,iCACf,aAGA,QACmB;AACnB,QAAM,eAAe,OAAO,WACzB,GAAG,OAAO,QAAQ,GAAG,OAAO,QAAQ,KACpC,OAAO;AAEV,QAAM,aAAa,kBAAkB,YAAY;AAIjD,QAAM,iBAAiB,MAAc;AACpC,QAAI,OAAO,WAAW,aAAa;AAClC,aAAO;AAAA,IACR;AACA,WAAO,OAAO,SAAS;AAAA,EACxB;AAEA,QAAM,0BAA0B,MAA8B;AAC7D,UAAM,OAAO,eAAe;AAC5B,WAAO,UAAU,MAAM,YAAY;AAAA,EACpC;AAGA,QAAM,YAAY,MAA8B;AAC/C,WAAO,wBAAwB;AAAA,EAChC;AAEA,QAAM,gBAAgB,CAAC,WAA2C;AACjE,UAAM,UAAU,UAAU;AAC1B,UAAM,eAAe,EAAE,GAAG,SAAS,GAAG,OAAO;AAC7C,WAAO,UAAU,cAAc,YAAY;AAAA,EAC5C;AAEA,SAAO;AAAA,IACN,UAAU,CAAC,QAA+B;AACzC,YAAM,SAAS,UAAU;AACzB,aAAO,OAAO,GAAG,KAAK;AAAA,IACvB;AAAA,IAEA,UAAU,CAAC,KAAa,UAAwB;AAC/C,UAAI,OAAO,WAAW,aAAa;AAClC;AAAA,MACD;AAEA,UAAI,CAAC,WAAW,SAAS,GAAG,GAAG;AAC9B,gBAAQ;AAAA,UACP,cAAc,GAAG,sCAAsC,YAAY;AAAA,QACpE;AACA;AAAA,MACD;AAEA,YAAM,UAAU,cAAc,EAAE,CAAC,GAAG,GAAG,MAAM,CAAC;AAC9C,aAAO,QAAQ,UAAU,CAAC,GAAG,IAAI,OAAO;AAAA,IACzC;AAAA,IAEA,cAAc,CAAC,KAAa,UAAwB;AACnD,UAAI,OAAO,WAAW,aAAa;AAClC;AAAA,MACD;AAEA,UAAI,CAAC,WAAW,SAAS,GAAG,GAAG;AAC9B,gBAAQ;AAAA,UACP,cAAc,GAAG,sCAAsC,YAAY;AAAA,QACpE;AACA;AAAA,MACD;AAEA,YAAM,UAAU,cAAc,EAAE,CAAC,GAAG,GAAG,MAAM,CAAC;AAC9C,aAAO,QAAQ,aAAa,CAAC,GAAG,IAAI,OAAO;AAAA,IAC5C;AAAA,IAEA,cAAc,MAA8B;AAC3C,aAAO,EAAE,GAAG,UAAU,EAAE;AAAA,IACzB;AAAA,IAEA,eAAe,CAAC,WAAyC;AACxD,UAAI,OAAO,WAAW,aAAa;AAClC;AAAA,MACD;AAEA,iBAAW,OAAO,OAAO,KAAK,MAAM,GAAG;AACtC,YAAI,CAAC,WAAW,SAAS,GAAG,GAAG;AAC9B,kBAAQ;AAAA,YACP,cAAc,GAAG,sCAAsC,YAAY;AAAA,UACpE;AAAA,QACD;AAAA,MACD;AAEA,YAAM,UAAU,cAAc,MAAM;AACpC,aAAO,QAAQ,aAAa,CAAC,GAAG,IAAI,OAAO;AAAA,IAC5C;AAAA,EACD;AACD;;;AC/UA,IAAM,iBAAiB;AAchB,IAAM,qBAAN,MAAyB;AAAA,EAG/B,YAAY,SAAiB,gBAAgB;AAC5C,SAAK,SAAS;AAAA,EACf;AAAA;AAAA;AAAA;AAAA,EAKQ,cAAc,MAAsB;AAC3C,WAAO,GAAG,KAAK,MAAM,GAAG,IAAI;AAAA,EAC7B;AAAA;AAAA;AAAA;AAAA,EAKQ,oBAAoB,MAAgC;AAC3D,QAAI,OAAO,WAAW,eAAe,CAAC,OAAO,gBAAgB;AAC5D,aAAO,CAAC;AAAA,IACT;AAEA,UAAM,aAAa,KAAK,cAAc,IAAI;AAC1C,UAAM,SAAS,OAAO,eAAe,QAAQ,UAAU;AAEvD,QAAI,CAAC,QAAQ;AACZ,aAAO,CAAC;AAAA,IACT;AAEA,QAAI;AACH,aAAO,KAAK,MAAM,MAAM;AAAA,IACzB,SAAS,OAAO;AACf,cAAQ,KAAK,mCAAmC,IAAI,MAAM,KAAK;AAC/D,aAAO,CAAC;AAAA,IACT;AAAA,EACD;AAAA;AAAA;AAAA;AAAA,EAKQ,oBAAoB,MAAc,SAAiC;AAC1E,QAAI,OAAO,WAAW,eAAe,CAAC,OAAO,gBAAgB;AAC5D;AAAA,IACD;AAEA,UAAM,aAAa,KAAK,cAAc,IAAI;AAC1C,QAAI;AACH,aAAO,eAAe,QAAQ,YAAY,KAAK,UAAU,OAAO,CAAC;AAAA,IAClE,SAAS,OAAO;AACf,cAAQ,MAAM,kCAAkC,IAAI,MAAM,KAAK;AAAA,IAChE;AAAA,EACD;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,iBAAiB,OAAoB,MAAoB;AACxD,QAAI,OAAO,WAAW,eAAe,CAAC,OAAO,gBAAgB;AAC5D;AAAA,IACD;AAEA,UAAM,UAAU,KAAK,oBAAoB,IAAI;AAC7C,UAAM,QAAQ,gBAAgB,KAAK;AACnC,UAAM,gBAAgB,IAAI,IAAI,QAAQ,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC;AAGxD,eAAW,QAAQ,OAAO;AACzB,UAAI,CAAC,cAAc,IAAI,IAAI,GAAG;AAC7B,gBAAQ,KAAK,EAAE,MAAM,OAAO,CAAC,EAAE,CAAC;AAAA,MACjC;AAAA,IACD;AAGA,SAAK,oBAAoB,MAAM,OAAO;AAAA,EACvC;AAAA;AAAA;AAAA;AAAA,EAKA,SAAS,MAAc,MAA2B;AACjD,UAAM,UAAU,KAAK,oBAAoB,IAAI;AAC7C,UAAM,QAAQ,QAAQ,KAAK,CAAC,MAAM,EAAE,SAAS,IAAI;AACjD,WAAO,OAAO,SAAS,CAAC;AAAA,EACzB;AAAA;AAAA;AAAA;AAAA,EAKA,SAAS,MAAc,MAAc,KAAa,OAAsB;AACvE,UAAM,UAAU,KAAK,oBAAoB,IAAI;AAC7C,QAAI,QAAQ,QAAQ,KAAK,CAAC,MAAM,EAAE,SAAS,IAAI;AAE/C,QAAI,CAAC,OAAO;AACX,cAAQ,EAAE,MAAM,OAAO,CAAC,EAAE;AAC1B,cAAQ,KAAK,KAAK;AAAA,IACnB;AAEA,UAAM,MAAM,GAAG,IAAI;AACnB,SAAK,oBAAoB,MAAM,OAAO;AAAA,EACvC;AAAA;AAAA;AAAA;AAAA,EAKA,cACC,MACA,MACA,SACO;AACP,UAAM,UAAU,KAAK,oBAAoB,IAAI;AAC7C,QAAI,QAAQ,QAAQ,KAAK,CAAC,MAAM,EAAE,SAAS,IAAI;AAE/C,QAAI,CAAC,OAAO;AACX,cAAQ,EAAE,MAAM,OAAO,CAAC,EAAE;AAC1B,cAAQ,KAAK,KAAK;AAAA,IACnB;AAEA,WAAO,OAAO,MAAM,OAAO,OAAO;AAClC,SAAK,oBAAoB,MAAM,OAAO;AAAA,EACvC;AAAA;AAAA;AAAA;AAAA,EAKA,YAAY,QAAqB,MAA2B;AAC3D,UAAM,WAAwB,CAAC;AAC/B,UAAM,UAAU,KAAK,oBAAoB,IAAI;AAG7C,eAAW,SAAS,SAAS;AAC5B,aAAO,OAAO,UAAU,MAAM,KAAK;AAAA,IACpC;AAEA,WAAO;AAAA,EACR;AAAA;AAAA;AAAA;AAAA,EAKA,aAAa,QAAqB,MAAc,MAA2B;AAC1E,UAAM,WAAwB,CAAC;AAC/B,UAAM,UAAU,KAAK,oBAAoB,IAAI;AAC7C,UAAM,QAAQ,gBAAgB,MAAM;AAGpC,eAAW,KAAK,OAAO;AACtB,YAAM,QAAQ,QAAQ,KAAK,CAAC,MAAM,EAAE,SAAS,CAAC;AAC9C,UAAI,OAAO;AACV,eAAO,OAAO,UAAU,MAAM,KAAK;AAAA,MACpC;AAEA,UAAI,MAAM,MAAM;AACf;AAAA,MACD;AAAA,IACD;AAEA,WAAO;AAAA,EACR;AAAA;AAAA;AAAA;AAAA,EAKA,SAAS,MAAuB;AAC/B,QAAI,OAAO,WAAW,eAAe,CAAC,OAAO,gBAAgB;AAC5D,aAAO;AAAA,IACR;AAEA,UAAM,aAAa,KAAK,cAAc,IAAI;AAC1C,UAAM,SAAS,OAAO,eAAe,QAAQ,UAAU;AACvD,WAAO,WAAW,QAAQ,WAAW;AAAA,EACtC;AAAA;AAAA;AAAA;AAAA,EAKA,WAAW,MAAoB;AAC9B,QAAI,OAAO,WAAW,eAAe,CAAC,OAAO,gBAAgB;AAC5D;AAAA,IACD;AAEA,UAAM,aAAa,KAAK,cAAc,IAAI;AAC1C,WAAO,eAAe,WAAW,UAAU;AAAA,EAC5C;AAAA;AAAA;AAAA;AAAA,EAKA,eAAe,MAAc,MAAoB;AAChD,UAAM,UAAU,KAAK,oBAAoB,IAAI;AAC7C,UAAM,WAAW,QAAQ,OAAO,CAAC,MAAM,EAAE,SAAS,IAAI;AACtD,SAAK,oBAAoB,MAAM,QAAQ;AAAA,EACxC;AACD;AAKO,IAAM,sBAAsB,IAAI,mBAAmB;;;AC1N1D,SAAS,eAAAA,cAAa,WAAW,gBAAgB;AAM1C,IAAM,0BAA4C;AAAA,EACxD,UAAU,CAAC,QAA+B;AACzC,QAAI,OAAO,WAAW,aAAa;AAClC,aAAO;AAAA,IACR;AACA,UAAM,SAAS,IAAI,gBAAgB,OAAO,SAAS,MAAM;AACzD,WAAO,OAAO,IAAI,GAAG;AAAA,EACtB;AAAA,EAEA,UAAU,CAAC,KAAa,UAAwB;AAC/C,QAAI,OAAO,WAAW,aAAa;AAClC;AAAA,IACD;AACA,UAAM,MAAM,IAAI,IAAI,OAAO,SAAS,IAAI;AACxC,QAAI,aAAa,IAAI,KAAK,KAAK;AAC/B,WAAO,QAAQ,UAAU,CAAC,GAAG,IAAI,IAAI,SAAS,CAAC;AAAA,EAChD;AAAA,EAEA,cAAc,CAAC,KAAa,UAAwB;AACnD,QAAI,OAAO,WAAW,aAAa;AAClC;AAAA,IACD;AACA,UAAM,MAAM,IAAI,IAAI,OAAO,SAAS,IAAI;AACxC,QAAI,aAAa,IAAI,KAAK,KAAK;AAC/B,WAAO,QAAQ,aAAa,CAAC,GAAG,IAAI,IAAI,SAAS,CAAC;AAAA,EACnD;AAAA,EAEA,cAAc,MAA8B;AAC3C,QAAI,OAAO,WAAW,aAAa;AAClC,aAAO,CAAC;AAAA,IACT;AACA,UAAM,SAAS,IAAI,gBAAgB,OAAO,SAAS,MAAM;AACzD,UAAM,SAAiC,CAAC;AACxC,eAAW,CAAC,KAAK,KAAK,KAAK,OAAO,QAAQ,GAAG;AAC5C,aAAO,GAAG,IAAI;AAAA,IACf;AACA,WAAO;AAAA,EACR;AAAA,EAEA,eAAe,CAAC,WAAyC;AACxD,QAAI,OAAO,WAAW,aAAa;AAClC;AAAA,IACD;AACA,UAAM,MAAM,IAAI,IAAI,OAAO,SAAS,IAAI;AAExC,QAAI,SAAS;AAEb,eAAW,CAAC,KAAK,KAAK,KAAK,OAAO,QAAQ,MAAM,GAAG;AAClD,UAAI,aAAa,IAAI,KAAK,KAAK;AAAA,IAChC;AACA,WAAO,QAAQ,aAAa,CAAC,GAAG,IAAI,IAAI,SAAS,CAAC;AAAA,EACnD;AACD;AAKO,SAAS,aACf,UAA4B,yBAC3B;AACD,QAAM,CAAC,QAAQ,SAAS,IAAI;AAAA,IAAiC,MAC5D,QAAQ,aAAa;AAAA,EACtB;AAGA,YAAU,MAAM;AACf,QAAI,OAAO,WAAW,aAAa;AAClC;AAAA,IACD;AAGA,cAAU,QAAQ,aAAa,CAAC;AAEhC,UAAM,iBAAiB,MAAM;AAC5B,gBAAU,QAAQ,aAAa,CAAC;AAAA,IACjC;AAEA,WAAO,iBAAiB,YAAY,cAAc;AAClD,WAAO,MAAM;AACZ,aAAO,oBAAoB,YAAY,cAAc;AAAA,IACtD;AAAA,EACD,GAAG,CAAC,OAAO,CAAC;AAEZ,QAAM,WAAWA;AAAA,IAChB,CAAC,QAA+B;AAC/B,aAAO,QAAQ,SAAS,GAAG;AAAA,IAC5B;AAAA,IACA,CAAC,OAAO;AAAA,EACT;AAEA,QAAM,WAAWA;AAAA,IAChB,CAAC,KAAa,UAAwB;AACrC,cAAQ,SAAS,KAAK,KAAK;AAC3B,gBAAU,QAAQ,aAAa,CAAC;AAAA,IACjC;AAAA,IACA,CAAC,OAAO;AAAA,EACT;AAEA,QAAM,eAAeA;AAAA,IACpB,CAAC,KAAa,UAAwB;AACrC,cAAQ,aAAa,KAAK,KAAK;AAC/B,gBAAU,QAAQ,aAAa,CAAC;AAAA,IACjC;AAAA,IACA,CAAC,OAAO;AAAA,EACT;AAEA,QAAM,eAAeA,aAAY,MAA8B;AAC9D,WAAO,QAAQ,aAAa;AAAA,EAC7B,GAAG,CAAC,OAAO,CAAC;AAEZ,QAAM,gBAAgBA;AAAA,IACrB,CAAC,cAA4C;AAC5C,cAAQ,cAAc,SAAS;AAC/B,gBAAU,QAAQ,aAAa,CAAC;AAAA,IACjC;AAAA,IACA,CAAC,OAAO;AAAA,EACT;AAEA,SAAO;AAAA,IACN;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACD;AACD;;;ACpIA,SAAS,eAAAC,cAAa,aAAAC,YAAW,WAAAC,UAAS,QAAQ,YAAAC,iBAAgB;AAgmB1C,gBAAAC,YAAA;AA3gBxB,SAAS,oBAA4B;AAGpC,QAAM,OAAO,OAAO,WAAW,EAAE,QAAQ,MAAM,EAAE;AACjD,SAAO,KAAK,MAAM,EAAE;AACrB;AAEO,SAAS,OAAO,EAAE,OAAO,SAAS,CAAC,EAAE,GAAgB;AAC3D,QAAM;AAAA,IACL;AAAA,IACA,eAAe;AAAA,IACf,gBAAgB;AAAA,IAChB,gBAAgB;AAAA,IAChB;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACD,IAAI;AAGJ,QAAM,sBAAsBC,SAAQ,MAAM;AACzC,QAAI,kBAAkB;AACrB,aAAO;AAAA,IACR;AAEA,WAAO,oBAAI,IAA6B;AAAA,EACzC,GAAG,CAAC,gBAAgB,CAAC;AACrB,QAAM,YAAY,aAAa,gBAAgB;AAG/C,QAAM,CAAC,YAAY,aAAa,IAAIC,UAAiB,MAAM;AAC1D,UAAM,eAAe,UAAU,SAAS,aAAa;AACrD,QAAI,cAAc;AACjB,aAAO;AAAA,IACR;AACA,UAAM,UAAU,kBAAkB;AAElC,QAAI,OAAO,WAAW,aAAa;AAClC,gBAAU,SAAS,eAAe,OAAO;AAAA,IAC1C;AACA,WAAO;AAAA,EACR,CAAC;AAGD,EAAAC,WAAU,MAAM;AACf,UAAM,UAAU,UAAU,SAAS,aAAa;AAChD,QAAI,WAAW,YAAY,YAAY;AACtC,oBAAc,OAAO;AAAA,IACtB,WAAW,CAAC,SAAS;AACpB,gBAAU,SAAS,eAAe,UAAU;AAAA,IAC7C;AAAA,EACD,GAAG,CAAC,YAAY,eAAe,SAAS,CAAC;AAIzC,QAAM,CAAC,aAAa,cAAc,IAAID,UAAwB,IAAI;AAKlE,QAAM,CAAC,cAAc,eAAe,IAAIA,UAAS,IAAI;AAGrD,QAAM,CAAC,gBAAgB,iBAAiB,IAAIA,UAAS,KAAK;AAC1D,QAAM,eAAe,OAAO,KAAK;AACjC,QAAM,oBAAoB,OAAO,KAAK;AAGtC,QAAM,CAAC,cAAc,eAAe,IAAIA,UAAS,CAAC;AAIlD,QAAM,WAAWD,SAAQ,MAAM;AAG9B,UAAM,IAAI;AACV,WAAO,aAAa,YAAY,OAAO,UAAU;AAAA,EAClD,GAAG,CAAC,OAAO,cAAc,YAAY,YAAY,CAAC;AAIlD,EAAAE,WAAU,MAAM;AACf,QAAI,CAAC,cAAc;AAClB;AAAA,IACD;AAEA,UAAM,UAAU,UAAU,SAAS,aAAa;AAChD,UAAM,aAAa,MAAM,cAAc;AACvC,UAAM,eAAe,YAAY;AAGjC,QAAI,gBAAgB,CAAC,SAAS;AAC7B,qBAAe,WAAW,UAAU;AACpC,sBAAgB,KAAK;AACrB;AAAA,IACD;AAIA,UAAM,aAAa,aAAa,SAAS,UAAU;AAGnD,QAAI,CAAC,YAAY;AAChB,qBAAe,aAAa;AAC5B,sBAAgB,KAAK;AACrB;AAAA,IACD;AAGA,QAAI,CAAC,MAAM,MAAM,IAAI,OAAO,GAAG;AAC9B,qBAAe,cAAc;AAC7B,sBAAgB,KAAK;AACrB;AAAA,IACD;AAGA,mBAAe,OAAO;AACtB,oBAAgB,KAAK;AAAA,EACtB,GAAG,CAAC,cAAc,WAAW,eAAe,OAAO,YAAY,YAAY,CAAC;AAM5E,EAAAA,WAAU,MAAM;AAEf,QAAI,cAAc;AACjB;AAAA,IACD;AAEA,UAAM,UAAU,UAAU,OAAO,aAAa,KAAK;AACnD,UAAM,aAAa,MAAM,cAAc;AACvC,UAAM,eAAe,YAAY;AAGjC,UAAM,aAAa,aAAa,SAAS,UAAU;AAInD,QAAI,CAAC,cAAc,WAAW,CAAC,cAAc;AAG5C,UAAI,gBAAgB,eAAe;AAClC,uBAAe,aAAa;AAAA,MAC7B;AACA;AAAA,IACD;AAGA,QAAI,WAAW,CAAC,MAAM,MAAM,IAAI,OAAO,GAAG;AAEzC,UAAI,gBAAgB,gBAAgB;AACnC,uBAAe,cAAc;AAAA,MAC9B;AACA;AAAA,IACD;AAIA,SACE,gBAAgB,iBAAiB,gBAAgB,mBAClD,WACA,MAAM,MAAM,IAAI,OAAO,GACtB;AAED,qBAAe,OAAO;AAAA,IACvB;AAIA,QAAI,gBAAgB,iBAAiB,gBAAgB,gBAAgB;AAGpE,UACC,WACA,YAAY,eACZ,MAAM,MAAM,IAAI,OAAO,KACvB,YACC;AAED,uBAAe,OAAO;AAAA,MACvB,OAAO;AAEN;AAAA,MACD;AAAA,IACD;AAKA,QACC,CAAC,kBAAkB,WACnB,CAAC,eACA,gBAAgB,CAAC,UACjB;AACD,mBAAa,iBAAiB,OAAO,UAAU;AAC/C,wBAAkB,UAAU;AAE5B,sBAAgB,CAAC,SAAS,OAAO,CAAC;AAAA,IACnC,WAAW,YAAY;AAEtB,wBAAkB,UAAU;AAAA,IAC7B;AAGA,QAAI,WAAW,YAAY,eAAe,MAAM,MAAM,IAAI,OAAO,GAAG;AAEnE,UAAI,eAAe,OAAO,SAAS,QAAQ,GAAG;AAE7C,cAAM,kBAAkB,cACrB,gBAAgB,OAAO,aAAa,QAAQ,IAC5C;AACH,cAAM,cAAc,oBAAoB;AAGxC,cAAM,aAAa,cAChB,gBAAgB,OAAO,SAAS,QAAQ,IACxC,YAAY,OAAO,SAAS,QAAQ;AAEvC,YAAI,YAAY;AAEf,oBAAU,aAAa,eAAe,UAAU;AAChD,yBAAe,UAAU;AACzB,yBAAe,YAAY,WAAW;AAAA,QACvC;AAAA,MACD,OAAO;AAEN,uBAAe,OAAO;AACtB,uBAAe,SAAS,WAAW;AAAA,MACpC;AAAA,IACD,WAAW,CAAC,SAAS;AAEpB,UAAI,cAAc,eAAe,aAAa;AAC7C,uBAAe,UAAU;AACzB,kBAAU,SAAS,eAAe,UAAU;AAAA,MAC7C,WAAW,CAAC,cAAc,aAAa;AAEtC,uBAAe,IAAI;AAAA,MACpB;AAAA,IACD;AAAA,EACD,GAAG;AAAA,IACF,UAAU;AAAA,IACV;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACD,CAAC;AAID,EAAAA,WAAU,MAAM;AAEf,iBAAa,UAAU;AAEvB,QAAI,CAAC,aAAa;AACjB;AAAA,IACD;AAGA,QAAI,eAAe,OAAO,aAAa,QAAQ,GAAG;AACjD,wBAAkB,IAAI;AACtB,mBAAa,UAAU;AAGvB,YAAM,WAAW,YAAY,OAAO,aAAa,QAAQ;AAEzD,UAAI,UAAU;AAEb,kBAAU,aAAa,eAAe,QAAQ;AAC9C,uBAAe,QAAQ;AACvB,uBAAe,UAAU,WAAW;AAAA,MACrC;AAEA,wBAAkB,KAAK;AAAA,IACxB;AAAA,EACD,GAAG,CAAC,aAAa,OAAO,UAAU,eAAe,WAAW,YAAY,CAAC;AAGzE,QAAM,WAAWC,aAAY,MAAM;AAClC,QAAI,CAAC,aAAa;AACjB;AAAA,IACD;AAEA,UAAM,WAAW,YAAY,OAAO,aAAa,QAAQ;AACzD,QAAI,CAAC,UAAU;AACd;AAAA,IACD;AAEA,UAAM,eAAe;AAKrB,UAAMC,eAAc,QAAQ,OAAO,WAAW;AAC9C,QAAI,aAA4B;AAChC,QAAIA,cAAa;AAChB,YAAM,WAAWA,aAAY;AAC7B,UAAI,OAAO,aAAa,UAAU;AACjC,qBAAa;AAAA,MACd,WAAW,MAAM,QAAQ,QAAQ,KAAK,SAAS,SAAS,GAAG;AAC1D,qBAAa,SAAS,CAAC;AAAA,MACxB,WAAW,OAAO,aAAa,YAAY;AAC1C,cAAM,aAAa,SAAS,QAAQ;AACpC,YAAI,OAAO,eAAe,UAAU;AACnC,uBAAa;AAAA,QACd,WAAW,MAAM,QAAQ,UAAU,KAAK,WAAW,SAAS,GAAG;AAC9D,uBAAa,WAAW,CAAC;AAAA,QAC1B;AAAA,MACD;AAAA,IACD;AAGA,UAAM,aAAa,eAAe,QAAQ,eAAe;AAIzD,QAAI,YAAY;AAEf,gBAAU,aAAa,eAAe,QAAQ;AAAA,IAC/C,OAAO;AAEN,gBAAU,SAAS,eAAe,QAAQ;AAAA,IAC3C;AAEA,mBAAe,QAAQ;AACvB,mBAAe,UAAU,YAAY;AAAA,EACtC,GAAG,CAAC,OAAO,aAAa,UAAU,cAAc,eAAe,SAAS,CAAC;AAEzE,QAAM,eAAeD,aAAY,MAAM;AAGtC,QAAI,OAAO,WAAW,eAAe,OAAO,QAAQ,SAAS,GAAG;AAC/D,aAAO,QAAQ,KAAK;AAAA,IACrB;AAAA,EACD,GAAG,CAAC,CAAC;AAEL,QAAM,WAAWA;AAAA,IAChB,CAAC,SAAiB;AACjB,UAAI,CAAC,MAAM,MAAM,IAAI,IAAI,GAAG;AAC3B,gBAAQ,KAAK,SAAS,IAAI,2BAA2B;AACrD;AAAA,MACD;AAEA,YAAM,eAAe;AAErB,qBAAe,IAAI;AACnB,gBAAU,SAAS,eAAe,IAAI;AACtC,qBAAe,MAAM,YAAY;AAAA,IAClC;AAAA,IACA,CAAC,OAAO,aAAa,cAAc,eAAe,SAAS;AAAA,EAC5D;AAEA,QAAM,aAAaA;AAAA,IAClB,CAAC,SAAiB;AACjB,UAAI,CAAC,MAAM,MAAM,IAAI,IAAI,GAAG;AAC3B,gBAAQ,KAAK,SAAS,IAAI,2BAA2B;AACrD;AAAA,MACD;AAEA,YAAM,eAAe;AAErB,qBAAe,IAAI;AACnB,gBAAU,aAAa,eAAe,IAAI;AAC1C,qBAAe,MAAM,YAAY;AAAA,IAClC;AAAA,IACA,CAAC,OAAO,aAAa,cAAc,eAAe,SAAS;AAAA,EAC5D;AAIA,QAAM,kBAAkBA,aAAY,MAAM;AACzC,QAAI,CAAC,aAAa;AACjB;AAAA,IACD;AAEA,sBAAkB,IAAI;AACtB,iBAAa,UAAU;AAGvB,UAAM,WAAW,YAAY,OAAO,aAAa,QAAQ;AAEzD,QAAI,UAAU;AAGb,gBAAU,aAAa,eAAe,QAAQ;AAC9C,qBAAe,QAAQ;AACvB,qBAAe,UAAU,WAAW;AAAA,IACrC;AAEA,sBAAkB,KAAK;AAAA,EACxB,GAAG,CAAC,aAAa,OAAO,UAAU,eAAe,WAAW,YAAY,CAAC;AAIzE,QAAM,iBAAiBA,aAAY,MAAM;AACxC,iBAAa,WAAW,UAAU;AAAA,EACnC,GAAG,CAAC,cAAc,UAAU,CAAC;AAG7B,QAAM,cAAcA;AAAA,IACnB,CAAC,KAAa,UAAmB;AAChC,UAAI,CAAC,aAAa;AACjB;AAAA,MACD;AACA,mBAAa,SAAS,YAAY,aAAa,KAAK,KAAK;AAEzD,sBAAgB,CAAC,SAAS,OAAO,CAAC;AAAA,IACnC;AAAA,IACA,CAAC,aAAa,cAAc,UAAU;AAAA,EACvC;AAEA,QAAM,mBAAmBA;AAAA,IACxB,CAAC,YAAqC;AACrC,UAAI,CAAC,aAAa;AACjB;AAAA,MACD;AACA,mBAAa,cAAc,YAAY,aAAa,OAAO;AAE3D,sBAAgB,CAAC,SAAS,OAAO,CAAC;AAAA,IACnC;AAAA,IACA,CAAC,aAAa,cAAc,UAAU;AAAA,EACvC;AAEA,QAAM,eAAeA;AAAA,IACpB,CAAC,SAAiB;AACjB,aAAO,aAAa,SAAS,YAAY,IAAI;AAAA,IAC9C;AAAA,IACA,CAAC,cAAc,UAAU;AAAA,EAC1B;AAGA,QAAM,iBAAiBA,aAAY,MAAM;AACxC,QAAI,CAAC,aAAa;AACjB,aAAO;AAAA,IACR;AACA,WAAO,QAAQ,OAAO,WAAW;AAAA,EAClC,GAAG,CAAC,OAAO,WAAW,CAAC;AAEvB,QAAM,gBAAgBA;AAAA,IACrB,CAAC,SAAiB;AACjB,aAAO,QAAQ,OAAO,IAAI;AAAA,IAC3B;AAAA,IACA,CAAC,KAAK;AAAA,EACP;AAEA,QAAM,UAAUA,aAAY,MAAM;AACjC,QAAI,CAAC,aAAa;AACjB,aAAO;AAAA,IACR;AACA,WAAO,YAAY,OAAO,aAAa,QAAQ,MAAM;AAAA,EACtD,GAAG,CAAC,OAAO,aAAa,QAAQ,CAAC;AAEjC,QAAM,cAAcA,aAAY,MAAM;AACrC,QAAI,CAAC,aAAa;AACjB,aAAO;AAAA,IACR;AAEA,QAAI,OAAO,WAAW,eAAe,OAAO,QAAQ,SAAS,GAAG;AAC/D,aAAO;AAAA,IACR;AAEA,WAAO,gBAAgB,OAAO,aAAa,QAAQ,MAAM;AAAA,EAC1D,GAAG,CAAC,OAAO,aAAa,QAAQ,CAAC;AAGjC,QAAM,eAAmCH;AAAA,IACxC,OAAO;AAAA,MACN;AAAA,MACA,OAAO;AAAA,MACP;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA,SAAS;AAAA,MACT;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA,aAAa,UAAU;AAAA,MACvB,iBAAiB,UAAU;AAAA,MAC3B,WAAW,UAAU;AAAA,IACtB;AAAA,IACA;AAAA,MACC;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACD;AAAA,EACD;AAEA,QAAM,cAAc,eAAe;AAInC,MAAI,cAAc;AACjB,WAAO;AAAA,EACR;AAGA,MAAI,gBAAgB;AACnB,WACC,gBAAAD,KAAC,cAAc,UAAd,EAAuB,OAAO,cAC7B,6BAAmB,gBAAAA,KAAC,SAAI,GAC1B;AAAA,EAEF;AAEA,SACC,gBAAAA,KAAC,cAAc,UAAd,EAAuB,OAAO,cAC9B,0BAAAA;AAAA,IAAC;AAAA;AAAA,MACA,MAAM;AAAA,MACN,MAAM;AAAA,MACN,kBAAkB;AAAA,MAClB;AAAA,MACA;AAAA;AAAA,EACD,GACD;AAEF;","names":["useCallback","useCallback","useEffect","useMemo","useState","jsx","useMemo","useState","useEffect","useCallback","currentNode"]}